<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker启动Nginx部署前端项目</title>
      <link href="/2023/06/30/Docker%E5%90%AF%E5%8A%A8Nginx%E9%83%A8%E7%BD%B2%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/"/>
      <url>/2023/06/30/Docker%E5%90%AF%E5%8A%A8Nginx%E9%83%A8%E7%BD%B2%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<ol><li><p>运行下列命令拉取镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx:(版本号)</span><br></pre></td></tr></table></figure></li><li><p>运行以下命令创建容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nginx -p 80:80 nginx:(版本号)</span><br></pre></td></tr></table></figure></li><li><p>将需要的nginx文件从容器中复制到本地</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建三个文件夹</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /mydata/nginx/html</span><br><span class="line"><span class="built_in">mkdir</span> -p /mydata/nginx/logs</span><br><span class="line"><span class="built_in">mkdir</span> -p /mydata/nginx/conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行以下命令把容器内的配置文件拷贝到本地的/mydata/nginx/conf/ 下</span></span><br><span class="line">docker container <span class="built_in">cp</span> nginx:/etc/nginx /mydata/nginx/conf/</span><br><span class="line"></span><br><span class="line"> <span class="comment">#由于拷贝完成后会在config中存在一个nginx文件夹，所以需要将它的内容移动到conf中</span></span><br><span class="line"><span class="built_in">mv</span> /mydata/nginx/conf/nginx/* /mydata/nginx/conf/</span><br><span class="line"><span class="built_in">rm</span> -rf /mydata/nginx/conf/nginx</span><br></pre></td></tr></table></figure></li><li><p>停止并删除原来的容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop nginx</span><br><span class="line">docker <span class="built_in">rm</span> nginx</span><br></pre></td></tr></table></figure></li><li><p>重新运行一个容器，并把刚才复制出来的目录进行挂载</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 --name nginx \</span><br><span class="line">-v /var/lib/nginx_data/nginx/html:/usr/share/nginx/html \</span><br><span class="line">-v /var/lib/nginx_data/nginx/logs:/var/log/nginx \</span><br><span class="line">-v /var/lib/nginx_data/nginx/conf/:/etc/nginx \</span><br><span class="line">--privileged \</span><br><span class="line">-d nginx:latest</span><br></pre></td></tr></table></figure></li><li><p>此时直接访问ip地址，看见如下信息则部署成功</p><p><img src="https://picture.adagio-project.icu/pic/202308092315051.png" alt="image-20230809231524021"></p></li><li><p>此时我们需要把我们的前端文件上传到服务器，然后在配置文件里指定地址</p></li><li><p>接下来只需要修改刚刚挂载的nginx.conf文件就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">user  root;     #如果默认配置文件的user是其他值，且访问nginx时还是报403，可以改成root</span><br><span class="line">worker_processes  auto;</span><br><span class="line"></span><br><span class="line">error_log  /var/log/nginx/error.log notice;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    #include /etc/nginx/conf.d/*.conf;   </span><br><span class="line">    #上面注释的配置代表启动时的配置会包括conf.d底下的其他配置，不注释可能会有其他问题</span><br><span class="line">#下面的配置根据自己的实际情况配置</span><br><span class="line">server &#123;</span><br><span class="line">listen80;#代表监听端口号，默认80</span><br><span class="line">server_name localhost;</span><br><span class="line">#这意味着当有请求发送到这台服务器的80端口时，Nginx会匹配请求中的Host标头，如果与localhost匹配，就会将请求交给这个配置块处理。</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">#根路径资源访问地址，如果是自己挂载的话，就得找到容器内挂载的文件地址</span><br><span class="line">root/usr/share/nginx/html/adagio-search-frontend;</span><br><span class="line">indexindex.html index.htm;#代表访问哪个文件，默认即可</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写一个RPC框架，我（小白）行，你（大佬）肯定行</title>
      <link href="/2023/05/21/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AARPC%E6%A1%86%E6%9E%B6%EF%BC%8C%E6%88%91%EF%BC%88%E5%B0%8F%E7%99%BD%EF%BC%89%E8%A1%8C%EF%BC%8C%E4%BD%A0%EF%BC%88%E5%A4%A7%E4%BD%AC%EF%BC%89%E8%82%AF%E5%AE%9A%E8%A1%8C/"/>
      <url>/2023/05/21/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AARPC%E6%A1%86%E6%9E%B6%EF%BC%8C%E6%88%91%EF%BC%88%E5%B0%8F%E7%99%BD%EF%BC%89%E8%A1%8C%EF%BC%8C%E4%BD%A0%EF%BC%88%E5%A4%A7%E4%BD%AC%EF%BC%89%E8%82%AF%E5%AE%9A%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>最近在看八股文的时候看到一个场景题：你会如何设计一个RPC框架？</p><p>他的解答是：RPC框架的基本作用是远程调用，调用的过程就是网络通信，通信就需要通信协议吧，通信的过程中参数如何传递，就需要序列化技术了吧，我们在使用RPC的时候肯定需要注册中心吧，那么就需要服务发现服务调用吧，分布式微服务中肯定不止一个服务提供者，如何挑选其一，就需要负载均衡了吧，如何优雅的发起请求让调用方像本地调用一样，就需要动态代理了吧，当我们把问题一个个拆解出来之后，每一个不就是我们熟悉的八股文了嘛</p><p>对啊，这不就是八股文吗，我相信绝大部分人肯定都背过这些八股文，但是，八股文背会了就真的能写出来一个RPC框架吗，于是，理论存在，实践开始！</p><p>首先远程调用，总得有一个服务提供者和服务调用者吧，于是：</p><p><img src="https://picture.adagio-project.icu/pic/202308082332459.png" alt="image-20230808233202225"></p><p><img src="https://picture.adagio-project.icu/pic/202308082332709.png" alt="image-20230808233220568"></p><p>因为服务提供者和服务调用者都需要依赖CalculateService接口，于是创建一个公共的Common类来存放这个接口，里面就两个简单的方法<img src="https://picture.adagio-project.icu/pic/202308082332519.png" alt="image-20230808233235382"></p><p><img src="https://picture.adagio-project.icu/pic/202308082332922.png" alt="image-20230808233248778"></p><p>至此预备工作就绪</p><p>接下来就是如何让他们进行远程调用，也就是RPC框架的编写</p><p>首先得回忆一下我们是怎么使用RPC框架的，拿Dubbo举例，我们会先在服务的调用方所需要的服务上面加上一个@DubboReference注解，在服务的提供方的接口实现类上面加上@DubboService注解，最后在两边的配置文件里加上注册中心的信息，然后就可以调用了</p><p>我们可以画出他具体的调用流程图</p><p><img src="https://picture.adagio-project.icu/pic/202308082333540.png" alt="image-20230808233301486"></p><p>接下来梳理整体的大需求：</p><ol start="0"><li><p>我们需要创建一个rpc框架包</p></li><li><p>使用了@Reference注解的接口，我们需要让他调用远程方法</p></li><li><p>使用了@Service注解的类，我们需要将他注册到注册中心</p></li><li><p>实现一个简易的注册中心，向外提供注册服务和获取服务信息的功能</p></li></ol><p>一步一步来解决</p><p>首先得把大需求整理成小需求</p><p>—使用了@Reference注解的接口，我们需要让他调用远程方法，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AdagioReference</span></span><br><span class="line">    <span class="keyword">private</span> CalculateService calculateService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">test</span> <span class="operator">=</span> consumer.test();</span><br><span class="line">        System.out.println(test);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> calculateService.add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>我们需要有一个@Reference，那么注解里需要什么属性呢，那就要看这个注解到底需要实现点什么功能</p><ul><li><p>我们需要根据注解里的信息找到具体的服务提供方，最基本的，服务的名字，也可以有服务的版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AdagioReference &#123;</span><br><span class="line">    String <span class="title function_">version</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;1.0&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//后续可以拓展其他属性，比如负载均衡策略，序列化策略，容错策略等等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>rpc框架需要根据这个注解找到哪些接口是要远程调用的</p><p>问题就是怎么找到，我们可以回想一下Spring里面的@ComponentScan注解，我们可以在该注解内传递一个扫描根路径，然后Spring会自动帮助我们去逐个扫描文件里面的类，类上面的属性、方法，那么有了这些，我们得知哪个接口有注解就很轻松了</p><p>于是我们可以写一个类似于@ComponentScan的工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">rootPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;&quot;</span>).getAbsolutePath();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">classPath</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader().getResource(<span class="string">&quot;&quot;</span>).getPath();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Class&lt;?&gt;&gt; getClasses(File file,List&lt;Class&lt;?&gt;&gt; classList) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span>(file.isDirectory())&#123;</span><br><span class="line">            File[] files = file.listFiles();</span><br><span class="line">            <span class="keyword">if</span>(files != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(File f:files)&#123;</span><br><span class="line">                    getClasses(f,classList);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> file.getName();</span><br><span class="line">            <span class="keyword">if</span>(name.endsWith(<span class="string">&quot;.class&quot;</span>))&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">classname</span> <span class="operator">=</span> file.getPath().replace(<span class="string">&quot;.class&quot;</span>,<span class="string">&quot;&quot;</span>).replace(classPath.replace(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;\\&quot;</span>).substring(<span class="number">1</span>),<span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;\\&quot;</span>,<span class="string">&quot;.&quot;</span>);</span><br><span class="line">                Class&lt;?&gt; clazz = Class.forName(classname);</span><br><span class="line">                classList.add(clazz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Class&lt;?&gt;&gt; getClasses() <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        <span class="keyword">return</span> getClasses(<span class="keyword">new</span> <span class="title class_">File</span>(classPath),<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Class&lt;?&gt;&gt; getClasses(String path) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        <span class="keyword">return</span> getClasses(<span class="keyword">new</span> <span class="title class_">File</span>(path),<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述工具类中我们可以指定扫描路径，去把该路径下的所有类扫描出来，之后我们只要根据需要去遍历这些类，找到里面带注解属性或方法，对其进行处理就行，此处我们是需要对所有加了@AdagioReference注解的属性，让他调用方法的时候，都是去调用远程方法</p><p>那么现在的问题就是，我们怎么样让这个属性去调用远程方法而不调用自己的方法，还有一个点，我们的属性都还没有初始化，执行方法肯定会报空指针。当我们用Dubbo的时候是不是完全不用考虑这种问题，因为框架都已经帮我们处理好了。那么现在我们作为框架的开发者，就需要我们自己来处理这些问题。</p><p>第一个问题：我们怎么样让这个属性去调用远程方法而不调用自己的方法，很显然这可以用动态代理来实现，并且我们都是对接口进行的代理，所以直接用JDK动态代理即可，但是不排除有人就喜欢用实现类来代理，这里就有一个拓展点，我们可以使用一个代理工厂，判断需要代理的到底是类还是接口，Dubbo内部就是使用这种方法（我自己还没做完这个拓展点，就不放上来了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkDynamicProxy</span> <span class="keyword">extends</span> <span class="title class_">AbstractDynamicProxy</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JdkDynamicProxy</span><span class="params">(Class&lt;?&gt; interfaceClass)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(interfaceClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                interfaceClass.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;interfaceClass&#125;,</span><br><span class="line">                (proxy,method,args)-&gt;&#123;</span><br><span class="line"><span class="comment">//增强逻辑</span></span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个问题：属性没有被初始化，Spring中两个重要思想之一的IOC就是用来解决这个问题的，但我们没有Spring，就手动的写一个简单Bean容器凑合一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanContainer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String,Object&gt; BEAN_CONTAINER = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BEAN_CONTAINER.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//初始化方法，去添加Bean</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在整体的思路就非常的明确了，Consumer引入rpc框架使用@AdagioReference注解，当Consumer启动时，会自动扫描找到所有的带@AdagioReference的属性，给他们创建动态代理然后放到Bean容器里去。</p><p>那么我们就先编写BeanContainer的初始化方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//上述的工具类</span></span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; classes = ClassUtils.getClasses();</span><br><span class="line">        <span class="comment">//遍历类对象里的属性对象，找到带注解的属性进行代理创建</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; clazz: classList) &#123;</span><br><span class="line">            Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">            <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                <span class="type">AdagioReference</span> <span class="variable">annotation</span> <span class="operator">=</span> field.getAnnotation(AdagioReference.class);</span><br><span class="line">                <span class="comment">//创建代理对象</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">serverName</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>.equals(annotation.name())?field.getName(): annotation.name();</span><br><span class="line">                <span class="comment">//todo 判断到底要以什么接口创建代理，这里就可以尝试用代理工厂了</span></span><br><span class="line">                <span class="type">JdkDynamicProxy</span> <span class="variable">jdkDynamicProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicProxy</span>(field.getType());</span><br><span class="line">                <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> jdkDynamicProxy.getProxy();</span><br><span class="line">                map.put(serverName,proxy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法有一个缺点就是：他是懒加载的，所以当我们第一次执行rpc调用的话会比较慢，所以此处可以参考Spring来解决（主要是我自己都还没看过Spring怎么解决的TAT）</p><p>接下来就可以编写代理对象的增强方法了，我们的目标是让他去调用远程的方法，可以按照以下步骤走</p><ol><li>根据注解里的信息向注册中心发起请求得到服务地址</li><li>获取到服务地址就可以发起请求</li></ol><p>那么就逐一编写</p><p>—根据注解里的信息向注册中心发起请求得到服务地址</p><p>注解里的信息？我们刚刚似乎只找到了注解所在位置，但没有去获取注解里面的信息吧，所以我们还得提前把信息保存下来，这个步骤可以在BeanContainer的初始化里写，因为他们都循环遍历了所有的类对象（不建议，还是得让他们各司其职），我写了一个工具类来实现注解信息导入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来缓存服务信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcCache</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String,RpcConfig&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; classList = ClassUtils.getClasses();</span><br><span class="line">            <span class="comment">//工具类，用于执行注解信息导入</span></span><br><span class="line">            AnnotationUtils.rpcConfigExecute(map,classList);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RpcConfig就是用于承载单个服务的注解里面的信息，和@AdagioReference里的属性对应就行，我在这里加了一个序列化格式，用于后面选定序列化方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务序列化格式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String serializeType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外我们还缺少注册中心，这个放在后面写，先假设我们有一个帮我们发请求的工具包</p><p>最后就是获取到目标地址该发请求了，告诉他我们需要调用哪一个接口的哪一个方法。哪一个接口？这直接传一个接口的名字就可以了；哪一个方法，这直接传一个名字可以吗？我们知道在java里是有方法重载的，如何区分重载的方法，是根据参数类型来区分的，那么是不是还需要传递一个参数类型的列表。这样我们就可以确定下来具体调用的是哪个接口的哪个方法了，但是我们有了方法没有参数还是不能调用的，所以还需要一个参数列表，综上，我们得到了调用方法的基本信息，在Dubbo中，这种信息有一个实体类来承载，叫Invoker，所以我们也定义一个自己的Invoker</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 承载方法调用的信息的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] paramsTypes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了可以发送的信息之后，我们是不是得让我们的rpc框架去帮助我们发送请求，那么发请求该怎么发，又有很多种选择，我们可以使用原生的URL，也可以使用Netty框架（Dubbo底层用的就是Netty），因为是手写rpc所以我们就简单一点，就发普通的http请求就行了（没错，主要是因为我不会Netty……..）</p><p>这里我就用HttpClient来发请求了</p><p>发请求，发什么，怎么发，发给谁</p><p>发什么，我们上面已经知道了，要调用接口方法就发它对应的Invoker就行了</p><p>怎么发，我们传输的是一个对象，网络传输对象肯定需要将对象序列化，我们可以选择jdk自带的序列化，也可以用其他开源的更好的序列化工具，我这里就选用Dubbo底层也使用的Hessian2</p><p>这里同样使用工厂模式打造一个序列化工厂，目前仅包含一个Hessain序列化器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化器工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializerFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, AbstractSerializer&gt; SERIALIZER_MAP = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AbstractSerializer <span class="title function_">getSerializer</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="type">AbstractSerializer</span> <span class="variable">serializer</span> <span class="operator">=</span> SERIALIZER_MAP.get(name);</span><br><span class="line">        <span class="keyword">if</span> (serializer == <span class="literal">null</span>) &#123;</span><br><span class="line">            serializer = createSerializer(name);</span><br><span class="line">            SERIALIZER_MAP.put(name,serializer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AbstractSerializer <span class="title function_">createSerializer</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;Hessian&quot;</span>.equals(name))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HessianSerializer</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;不含有对应的序列化器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HessianSerializer</span> <span class="keyword">implements</span> <span class="title class_">AbstractSerializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T obj) &#123;</span><br><span class="line">        <span class="type">byte</span>[] result;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">Hessian2Output</span> <span class="variable">hessian2Output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hessian2Output</span>(byteArrayOutputStream);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hessian2Output.startMessage();</span><br><span class="line">            hessian2Output.writeObject(obj);</span><br><span class="line">            hessian2Output.flush();</span><br><span class="line">            hessian2Output.completeMessage();</span><br><span class="line">            result = byteArrayOutputStream.toByteArray();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                hessian2Output.close();</span><br><span class="line">                byteArrayOutputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        T result;</span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">        <span class="type">Hessian2Input</span> <span class="variable">hessian2Input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hessian2Input</span>(byteArrayInputStream);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hessian2Input.startMessage();</span><br><span class="line">            result = (T) hessian2Input.readObject();</span><br><span class="line">            hessian2Input.completeMessage();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                hessian2Input.close();</span><br><span class="line">                byteArrayInputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发给谁，肯定发给已经获取到地址的某一个服务了</p><p>至此，所有消费端发请求的步骤准备好了</p><p>接下来就是实现发请求功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(proxy,method,args)-&gt;&#123;</span><br><span class="line">    <span class="comment">//Invoker创建</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> interfaceClass.getSimpleName();</span><br><span class="line">    <span class="type">Invoker</span> <span class="variable">invoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Invoker</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">RpcConfig</span> <span class="variable">rpcConfig</span> <span class="operator">=</span> RpcCache.map.get(自己定义的key);</span><br><span class="line">    invoker.setMethodName(method.getName());</span><br><span class="line">    invoker.setParams(args);</span><br><span class="line">    invoker.setSerializeType(rpcConfig.getSerializeType());</span><br><span class="line">    invoker.setInterfaceName(name);</span><br><span class="line">    invoker.setParamsTypes(method.getParameterTypes());</span><br><span class="line">    <span class="comment">//去注册中心里获取服务信息</span></span><br><span class="line">    <span class="comment">//此处的Register为自己编写的一个注册中心的starter</span></span><br><span class="line">    <span class="type">RegisterClient</span> <span class="variable">registerClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegisterClient</span>(<span class="string">&quot;localhost&quot;</span>,<span class="string">&quot;8081&quot;</span>);</span><br><span class="line">    <span class="type">RegisterData</span> <span class="variable">registerData</span> <span class="operator">=</span> registerClient.getRegisterData(rpcConfig.getName(),rpcConfig.getVersion());</span><br><span class="line">    <span class="comment">//发送请求</span></span><br><span class="line">    <span class="comment">//可以做负载均衡，目前还没实现</span></span><br><span class="line">    Set&lt;String&gt; paths = registerData.getPath();</span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(paths).get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//自定义的发请求工具类</span></span><br><span class="line">    <span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpClient</span>();</span><br><span class="line">    <span class="keyword">return</span> client.doPost(path, invoker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是client的doPost方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">doPost</span><span class="params">(String path,Invoker invoker)</span>&#123;</span><br><span class="line">    <span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClients.createDefault();</span><br><span class="line">    <span class="comment">//基本信息配置</span></span><br><span class="line">    <span class="comment">//todo path不够优雅</span></span><br><span class="line">    <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;http://&quot;</span>+path);</span><br><span class="line">    httpPost.setHeader(<span class="string">&quot;serializeType&quot;</span>,invoker.getSerializeType());</span><br><span class="line">    <span class="comment">//序列化工厂获取对应序列化器</span></span><br><span class="line">    <span class="type">AbstractSerializer</span> <span class="variable">serializer</span> <span class="operator">=</span> SerializerFactory.getSerializer(invoker.getSerializeType());</span><br><span class="line">    <span class="comment">//序列化invoker</span></span><br><span class="line">    <span class="type">byte</span>[] bytes = serializer.serialize(invoker);</span><br><span class="line">    httpPost.setEntity(<span class="keyword">new</span> <span class="title class_">ByteArrayEntity</span>(bytes));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//发送请求</span></span><br><span class="line">        <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> client.execute(httpPost).getEntity();</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        entity.writeTo(outputStream);</span><br><span class="line">        <span class="type">byte</span>[] byteArray = outputStream.toByteArray();</span><br><span class="line">        <span class="keyword">return</span> serializer.deserialize(byteArray);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，消费者端的全部流程走完</p></li></ul></li><li><p>使用了@AdagioService注解的类，我们需要将他注册到注册中心</p><p>首先这个注解里需要有什么方法，那肯定和@AdagioReference里面几乎是对应的了，消费者方需要根据服务名称和版本号来查找到服务，所以服务方肯定得定义自己的名称和版本号，所以这两个是最基本的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AdagioService &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String <span class="title function_">version</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;1.0&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何查找并注册呢，这个就和@AdagioReference的查找和注册异曲同工了，这里就不放代码了，注册到注册中心也调用了自己编写的一个starter，发起一个请求到注册中心就行</p><p>作为服务的提供者，肯定需要能接受请求吧，那么如何接受请求呢，可以用netty（如果我会的话），这里还是用Tomcat吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(String hostname,Integer port)</span>&#123;</span><br><span class="line">        <span class="type">Tomcat</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> tomcat.getServer();</span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> server.findService(<span class="string">&quot;Tomcat&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Connector</span> <span class="variable">connector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Connector</span>();</span><br><span class="line">        connector.setPort(port);</span><br><span class="line"></span><br><span class="line">        <span class="type">StandardEngine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEngine</span>();</span><br><span class="line">        engine.setDefaultHost(hostname);</span><br><span class="line"></span><br><span class="line">        <span class="type">StandardHost</span> <span class="variable">host</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardHost</span>();</span><br><span class="line">        host.setName(hostname);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">StandardContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardContext</span>();</span><br><span class="line">        context.setPath(contextPath);</span><br><span class="line">        context.addLifecycleListener(<span class="keyword">new</span> <span class="title class_">Tomcat</span>.FixContextListener());</span><br><span class="line"></span><br><span class="line">        host.addChild(context);</span><br><span class="line">        engine.addChild(host);</span><br><span class="line"></span><br><span class="line">        service.setContainer(engine);</span><br><span class="line">        service.addConnector(connector);</span><br><span class="line"></span><br><span class="line">        tomcat.addServlet(contextPath,<span class="string">&quot;dispatcher&quot;</span>,<span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>());</span><br><span class="line">        context.addServletMappingDecoded(<span class="string">&quot;/*&quot;</span>,<span class="string">&quot;dispatcher&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//用于实现@AdagioService的类遍历及class对象缓存</span></span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; classList = ClassUtils.getClasses();</span><br><span class="line">            AnnotationUtils.serverExecute(classList);</span><br><span class="line">            tomcat.start();</span><br><span class="line">            tomcat.getServer().await();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (LifecycleException | ClassNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码启动了一个tomcat，并且配置了一个dispatcherServlet进行消息转发</p><p>如下是dispatcherServlet代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HttpServerHandler</span>().handler(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中HttpServerHandler才是最终处理请求的部分，才是重点</p><p>分析一下，我们接收到请求应该做什么</p><p>第一，我们接收到的是一个Invoker对象，肯定得先反序列化</p><p>第二，Invoker对象里包含了接口名，方法名，方法参数，参数类型，所以得用反射调用</p><p>所以，如下就是HttpServerHandler的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpServerHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstractHandler</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//todo 目前为可选的序列化方式，后续可添加自定义序列化方式</span></span><br><span class="line">            <span class="comment">//获取输入流并把输入流内容读到byte数组</span></span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            IOUtils.copy(req.getInputStream(),bos);</span><br><span class="line">            <span class="type">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">            <span class="type">String</span> <span class="variable">serializeType</span> <span class="operator">=</span> req.getHeader(<span class="string">&quot;serializeType&quot;</span>);</span><br><span class="line">            <span class="type">AbstractSerializer</span> <span class="variable">serializer</span> <span class="operator">=</span> SerializerFactory.getSerializer(serializeType);</span><br><span class="line">            <span class="comment">//反序列化</span></span><br><span class="line">            <span class="type">Invoker</span> <span class="variable">invoker</span> <span class="operator">=</span> serializer.deserialize(bytes);</span><br><span class="line">            <span class="type">String</span> <span class="variable">interfaceName</span> <span class="operator">=</span> invoker.getInterfaceName();</span><br><span class="line">            Object[] params = invoker.getParams();</span><br><span class="line">            <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> invoker.getMethodName();</span><br><span class="line">            Class&lt;?&gt;[] types = invoker.getParamsTypes();</span><br><span class="line">            <span class="comment">//反射调用</span></span><br><span class="line">            Class&lt;?&gt; specificClass = LocalRegister.getSpecificClass(interfaceName);</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> specificClass.getMethod(methodName, types);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> method.invoke(specificClass.newInstance(), params);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//写入response中</span></span><br><span class="line">            IOUtils.write(serializer.serialize(obj), resp.getOutputStream());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | NoSuchMethodException | InvocationTargetException |</span><br><span class="line">                 IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，服务调用端和服务提供段的代码均处理完毕，注册中心的代码就不放上来了，写的有点烂TAT</p><p>那么就来调用试下吧</p><ol><li><p>启动注册中心</p><p><img src="https://picture.adagio-project.icu/pic/202308082333831.png" alt="image-20230808233320617"></p></li><li><p>启动服务提供者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AdagioService(name = &quot;CalculateService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculateServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CalculateService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">add</span><span class="params">(Integer a, Integer b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">minus</span><span class="params">(Integer a, Integer b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Provider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HttpServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpServer</span>();</span><br><span class="line">        server.start(<span class="string">&quot;localhost&quot;</span>,<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picture.adagio-project.icu/pic/202308082333740.png" alt="image-20230808233335514"></p></li><li><p>启动服务消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AdagioReference</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">CalculateService</span> <span class="variable">calculateService</span> <span class="operator">=</span> (CalculateService) BeanContainer.getBean(<span class="string">&quot;calculateService&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">test</span> <span class="operator">=</span> consumer.test();</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结果为：&quot;</span>+test);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> calculateService.add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里因为没有实现Bean的自动注入，所以就手动取Bean了</p><p>我们此时调用的是add方法，结果应该返回3</p><p><img src="https://picture.adagio-project.icu/pic/202308082333327.png" alt="image-20230808233351066"></p><p>最终我们实现了远程调用</p></li></ol></li></ol><p>做个小小的总结，写了一个简易的rpc框架，其实我感觉一点也不简单，要考虑的点非常的多，真的需要全局的思维，并且还要给后续开发留下余地，让新功能的接入不影响老功能，有时考虑的太多反而不知道如何下手了，左右为难。</p><p>从看到这篇八股文，到我写出一个能实现基本功能的小框架，也花了一个多月的时间，收获肯定有，最起码的是我对Dubbo的执行过程更加的清楚了。还有写代码，打通思路很重要，在写的时候我经常会写着写着就不知道在写点什么东西了，包括类与类之间的调用，接下来该去写什么，都会突然间迷糊住，这次写一篇总结，也算把整体的流程梳理了一遍，印象应该很深刻了</p><p>然后再总结一下这里面还要修改的点和可以提高的点，还蛮多的</p><p>1.收发请求还是得用netty</p><p>2.动态代理工厂还没实现</p><p>3.负载均衡策略，可以用个策略模式</p><p>4.注册中心太不完善</p><p>5.可以添加服务的心跳检测</p><p>6.日志处理不够好，还没百分百还原类似于本地调用的感觉</p><p>7.还得手动注入Bean</p><p>8.有些值还是写死在代码里的，得动态获取</p><p>9.有些代码还是太臃肿，可以考虑复用</p><p>10…………………………………很多很多值得修改</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一下看公司项目学到的新东西</title>
      <link href="/2023/05/10/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E7%9C%8B%E5%85%AC%E5%8F%B8%E9%A1%B9%E7%9B%AE%E5%AD%A6%E5%88%B0%E7%9A%84%E6%96%B0%E4%B8%9C%E8%A5%BF/"/>
      <url>/2023/05/10/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E7%9C%8B%E5%85%AC%E5%8F%B8%E9%A1%B9%E7%9B%AE%E5%AD%A6%E5%88%B0%E7%9A%84%E6%96%B0%E4%B8%9C%E8%A5%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="一些没见过但是能看懂的新鲜玩意儿"><a href="#一些没见过但是能看懂的新鲜玩意儿" class="headerlink" title="一些没见过但是能看懂的新鲜玩意儿"></a>一些没见过但是能看懂的新鲜玩意儿</h2><h3 id="1-within注解"><a href="#1-within注解" class="headerlink" title="1.@within注解"></a>1.@within注解</h3><p>这个注解是Spring AOP里面的一个注解，和@target作用类似，都是用于配置切点（基于注解的形式）的，区别在于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示的是对标注了A1注解的类里面所有的方法，包括子类里面没有重写父类的方法都可以被看做是切点</span></span><br><span class="line"><span class="meta">@Around(&quot;@within(com.example.A1)&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//表示的是对标注了A1注解的类里面所有的方法，都可以看做切点</span></span><br><span class="line"><span class="meta">@Around(&quot;@target(com.example.A1)&quot;)</span></span><br></pre></td></tr></table></figure><p>因为平常写AOP的时候没有写过对类的全部方法进行增强的情况，所以第一次看到@within注解有点陌生</p><h3 id="2-Methods-annotated-with-‘-Transactional’-must-be-overridable"><a href="#2-Methods-annotated-with-‘-Transactional’-must-be-overridable" class="headerlink" title="2.Methods annotated with ‘@Transactional’ must be overridable"></a>2.Methods annotated with ‘@Transactional’ must be overridable</h3><p>这句话翻译过来的意思就是被@Transactional修饰的方法必须是可重写的，我在公司的代码里发现前辈在静态方法上面使用了@Transactional注解，典型错误啊，也同时对应了两个知识点</p><p>静态方法不能重写</p><p>@Transactional不能用在不可重写的方法上，比如final，static方法上</p><p>其次可以回顾一下为什么@Transactional不能用在不可重写的方法上，我思考了一下是因为动态代理，因为事务的底层是AOP，AOP底层是动态代理，动态代理里面有常见的两种，JDK动态代理和CGLIB动态代理，一种是通过基于接口实现，一种是创建子类实现，都需要重写父类的方法，如果修饰不可重写的方法自然就矛盾了</p><h3 id="3-Async注解"><a href="#3-Async注解" class="headerlink" title="3.@Async注解"></a>3.@Async注解</h3><p>这个注解我见过，但是一直没用过，看了前辈的用法大概了解了使用的过程</p><p>@Async()，异步注解，被这个注解修饰的方法将不会阻塞主方法的运行，里面可以传一个value参数，代表着你需要用哪个线程池，如果不传则会使用系统默认的线程池</p><p>他所使用的线程池我也没见过，用的是ThreadPoolTaskExecutor，我一开始还没发现这个东西我没见过，直到我看到了他在里面调用了executor.initialize();，我记得我当时学JUC的时候没有用过这个方法，好像是直接创建完线程池就直接用了，后来才发现这个ThreadPoolTaskExecutor根本不是util.concurrent包下的，而是spring里面的线程池，是对ThreadPoolExecutor的一个封装</p><p>然后他们是把线程池当做一个Bean创建出来了，在里面配置了核心线程数，最大线程数，队列大小，名称前缀和拒绝策略，这些值都是通过@Value注解从配置文件里面读取的</p><p>另外在使用这个注解之前得先开启异步支持，得在启动类或者配置类上加上@EnableAsync注解</p><h3 id="4-Valid注解"><a href="#4-Valid注解" class="headerlink" title="4.@Valid注解"></a>4.@Valid注解</h3><p>这个注解也是见过但没有用过的，在controller层的方法入参前面加上@Valid注解，在方法执行前就会去找到对应实体类，看看哪些属性上有限制。</p><p>但是他们每个入参上都加上了这个注解，但是每个实体类里都没有加限制条件，可能是有备无患吧</p><h3 id="5-BindingResult"><a href="#5-BindingResult" class="headerlink" title="5.BindingResult"></a>5.BindingResult</h3><p>确确实实没见过这个类，也是spring提供的一个类，可以自动接收@Valid校验结果之后的值，用法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">getResponse</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> LoginRequest request,BindingResult result)</span>&#123;</span><br><span class="line">    <span class="comment">//先去判断result结果，看看是校验通过还是没通过，可以写个工具类来判断</span></span><br><span class="line">    ParameterValidator.validate(<span class="string">&quot;getSystemResp&quot;</span>,validResult);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工具类，判断是否有错，有错的话就记录参数和错误信息并抛异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(String serviceName, BindingResult result)</span> <span class="keyword">throws</span> ServiceException &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            buffer.append(serviceName + <span class="string">&quot;接口参数校验不通过：&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (FieldError error : result.getFieldErrors()) &#123;</span><br><span class="line">                buffer.append(error.getField() + error.getDefaultMessage() + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> buffer.toString();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(msg.substring(<span class="number">0</span>, msg.lastIndexOf(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="6-LogFactory-getLog"><a href="#6-LogFactory-getLog" class="headerlink" title="6.LogFactory.getLog"></a>6.LogFactory.getLog</h3><p>这个是apache包里面的日志记录方法，我一开始不明白为什么这个方法里要传入class对象，后来一查发现class对象是用来做日志标题起到区分作用的，我平常打日志全都是log.info，log.error这样，我只知道他会在控制台有输出，至于他会保存吗，他保存到哪里，线上出问题了我该怎么看日志，这些我都不明白，还是得去看看相关资料</p><h3 id="7-ESB"><a href="#7-ESB" class="headerlink" title="7.ESB"></a>7.ESB</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#esb调用</span><br><span class="line">esb.op.id = ********</span><br><span class="line">esb.password = ********************</span><br></pre></td></tr></table></figure><p>在配置文件里看到了这样一段配置，就去查了一下ESB是什么意思</p><p>ESB是Enterprise Service Bus的简称，中文翻译为企业服务总线，企业服务总线是一个实现系统间集成和互联互通的重要技术架构，可以理解为是一种消息和服务集成的中间件平台。</p><p>简单来说就是用来降低系统互联的复杂度，假如一个业务系统有十几个小系统，他们如果彼此互相链接就会错综复杂，如果这些系统又是由不同的厂家制作，那么系统构建语言不同，数据传输格式不同，通信协议不同，这样统一起来就很麻烦，于是ESB相当于一个中台，统一的接收所有请求，进行消息转换后再转发给接收请求的系统</p><p>具体的内容可以看这篇文章：<a href="https://www.jianshu.com/p/10ec5b86296f">https://www.jianshu.com/p/10ec5b86296f</a></p><h3 id="8-spring-jms"><a href="#8-spring-jms" class="headerlink" title="8.spring.jms"></a>8.spring.jms</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#指定最小的并发消费者数量</span><br><span class="line">spring.jms.listener.concurrency=<span class="number">5</span></span><br><span class="line">#指定最大的并发消费者数量</span><br><span class="line">spring.jms.listener.max-concurrency=<span class="number">10</span></span><br></pre></td></tr></table></figure><p>又是一段没有看过的配置，去查了一下知道，这个jms是Java Messaging Service的缩写，是Java平台面向消息中间件推出的统一API（和JDBC类似，JDBC也支持各个数据库）</p><p>虽然但是，知道了jms是啥但也不知道怎么用，项目里除了配置里有写，其他地方好像没有用到mq啊</p><h3 id="9-spring-sleuth"><a href="#9-spring-sleuth" class="headerlink" title="9.spring.sleuth"></a>9.spring.sleuth</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#开启sleuth支持</span><br><span class="line">spring.sleuth.enabled=<span class="literal">true</span></span><br><span class="line">#跟踪信息收集采样比例，默认 <span class="number">0.1</span>，为 <span class="number">1</span> 是即 <span class="number">100</span>%，收集所有</span><br><span class="line">spring.sleuth.sampler.percentage=<span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>又是spring的东西，项目组的前辈应该对spring的各个组件都很了解了吧</p><p>Sleuth 通过 traceId 实现了对分布式系统调用链路的跟踪。在一次服务请求链路中，会保持并传递一个 traceId，从而将不同服务的请求跟踪信息串联起来，不同服务的 traceId 相同表示处在同一请求链中。</p><p>是个实现链路追踪的组件，我还没有接触过，现在主流的链路追踪工具是skywalking和prometheus，sleuth就没怎么听说过了</p>]]></content>
      
      
      <categories>
          
          <category> 日常记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo学习笔记</title>
      <link href="/2023/02/10/Dubbo/"/>
      <url>/2023/02/10/Dubbo/</url>
      
        <content type="html"><![CDATA[<h2 id="一-Dubbo前置相关概念"><a href="#一-Dubbo前置相关概念" class="headerlink" title="一.Dubbo前置相关概念"></a>一.Dubbo前置相关概念</h2><h3 id="大型互联网项目架构目标"><a href="#大型互联网项目架构目标" class="headerlink" title="大型互联网项目架构目标"></a>大型互联网项目架构目标</h3><h4 id="衡量网站的性能指标"><a href="#衡量网站的性能指标" class="headerlink" title="衡量网站的性能指标:"></a>衡量网站的性能指标:</h4><ul><li><p>响应时间:指执行一个请求从开始到最后收到响应数据所花费的总体时间。</p></li><li><p>并发数:指系统同时能处理的请求数量。</p><ul><li><p>并发连接数:指的是客户端向服务器发起请求，并建立了TCP连接。每秒钟服务器连接的总TCP数量</p></li><li><p>请求数:也称为QPS(Query Per Second)指每秒多少请求.</p></li><li><p>并发用户数:单位时间内有多少用户</p></li></ul></li><li><p>吞吐量:指单位时间内系统能处理的请求数量。</p><ul><li><p>QPS: Query Per Second每秒查询数。</p></li><li><p>TPS: Transactions Per Second每秒事务数。</p></li><li><p>一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。</p></li><li><p>一个页面的一次访问，只会形成一个TPS;但一次页面请求，可能产生多次对服务器的请求，就会有多个QPS</p></li></ul></li><li><p>高性能:提供快速的访问体验。</p></li><li><p>高可用:网站服务一直可以正常访问。</p></li><li><p>可伸缩:通过硬件增加&#x2F;减少，提高&#x2F;降低处理能力。</p></li><li><p>高可扩展:系统间耦合低，方便的通过新增&#x2F;移除方式，增加&#x2F;减少新的功能&#x2F;模块。</p></li><li><p>安全性:提供网站安全访问和数据加密，安全存储等策略。敏捷性:随需应变，快速响应。</p></li></ul><h3 id="集群和分布式"><a href="#集群和分布式" class="headerlink" title="集群和分布式"></a>集群和分布式</h3><ul><li>集群:很多“人”一起，干一样的事。</li><li>分布式:很多“人”一起，干不一样的事。这些不一样的事，合起来是一件大事。</li></ul><h6 id="单机架构"><a href="#单机架构" class="headerlink" title="单机架构"></a>单机架构</h6><p><img src="https://picture.adagio-project.icu/pic/image-20230209223951002.png" alt="image-20230209223951002"></p><h6 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h6><p><img src="https://picture.adagio-project.icu/pic/image-20230209224154902.png" alt="image-20230209224154902"></p><h6 id="集群分布式架构"><a href="#集群分布式架构" class="headerlink" title="集群分布式架构"></a>集群分布式架构</h6><p><img src="https://picture.adagio-project.icu/pic/image-20230209224312550.png" alt="image-20230209224312550"></p><h3 id="架构演进"><a href="#架构演进" class="headerlink" title="架构演进"></a>架构演进</h3><p><img src="https://picture.adagio-project.icu/pic/image-20230210210445618.png" alt="image-20230210210445618"></p><p><img src="https://picture.adagio-project.icu/pic/image-20230210210755596.png" alt="image-20230210210755596"></p><p><img src="https://picture.adagio-project.icu/pic/image-20230210211155836.png" alt="image-20230210211155836"></p><p><img src="https://picture.adagio-project.icu/pic/image-20230210211446701.png" alt="image-20230210211446701"></p><p><img src="https://picture.adagio-project.icu/pic/image-20230210211655115.png" alt="image-20230210211655115"></p><p><img src="https://picture.adagio-project.icu/pic/image-20230210211817389.png" alt="image-20230210211817389"></p><h2 id="二-Dubbo入门"><a href="#二-Dubbo入门" class="headerlink" title="二.Dubbo入门"></a>二.Dubbo入门</h2><h3 id="Dubbo概念"><a href="#Dubbo概念" class="headerlink" title="Dubbo概念"></a>Dubbo概念</h3><ul><li><p>Dubbo是阿里巴巴公司开源的一个高性能，轻量级的RPC框架</p></li><li><p>致力于提供高性能和透明化的RP(远程服务调用方案，以及SOA服务治理方案,</p></li><li><p>官网: <a href="http://dubbo.apache.org/">http://dubbo.apache.org</a></p></li></ul><h3 id="Dubbo架构"><a href="#Dubbo架构" class="headerlink" title="Dubbo架构"></a>Dubbo架构</h3><p><img src="https://picture.adagio-project.icu/pic/image-20230210224147434.png" alt="image-20230210224147434"></p><h3 id="Zookeeper安装"><a href="#Zookeeper安装" class="headerlink" title="Zookeeper安装"></a>Zookeeper安装</h3><p>ps：Zookeeper只是充当注册中心作用，你也可以使用其他注册中心，如nacos，eureka</p><ol><li>上传zookeeper安装包</li></ol><p><img src="https://picture.adagio-project.icu/pic/image-20230211104723862.png" alt="image-20230211104723862"></p><ol start="2"><li><p>在&#x2F;opt目录下创建zookeeper文件夹，把安装包移动到该目录下并解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打开 opt目录</span></span><br><span class="line">cd /opt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建zooKeeper目录</span></span><br><span class="line">mkdir  zooKeeper</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将zookeeper安装包移动到 /opt/zooKeeper</span></span><br><span class="line">mv apache-zookeeper-3.5.6-bin.tar.gz /opt/zookeeper/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解压该文件</span></span><br><span class="line">tar -zxvf apache-zookeeper-3.5.6-bin.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>修改zoo.cfg</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打开目录</span></span><br><span class="line">cd /opt/zooKeeper/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建zooKeeper存储目录</span></span><br><span class="line">mkdir  zkdata</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改zoo.cfg</span></span><br><span class="line">vim /opt/zooKeeper/apache-zooKeeper-3.5.6-bin/conf/zoo.cfg</span><br></pre></td></tr></table></figure><p>把dataDir改成”dataDir&#x3D;&#x2F;opt&#x2F;zookeeper&#x2F;zkdata”</p><p><img src="https://picture.adagio-project.icu/pic/image-20230211110245460.png" alt="image-20230211110245460"></p></li><li><p>启动zookeeper</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/zooKeeper/apache-zooKeeper-3.5.6-bin/bin/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动</span></span><br><span class="line"> ./zkServer.sh  start</span><br></pre></td></tr></table></figure><p><img src="https://picture.adagio-project.icu/pic/image-20230211110747838.png" alt="image-20230211110747838"></p></li></ol><p>​看到上述信息说明启动成功</p><p>​<img src="https://picture.adagio-project.icu/pic/image-20230211110914105.png"></p><p>​可以用 .&#x2F;zkServer.sh status来查看zookeeper的启动状态</p><h3 id="Dubbo快速入门"><a href="#Dubbo快速入门" class="headerlink" title="Dubbo快速入门"></a>Dubbo快速入门</h3><ul><li><p>原始写法</p><p>通过在UserController中引入UserService依赖达到调用目的</p><p><img src="https://picture.adagio-project.icu/pic/image-20230211203405156.png" alt="image-20230211203405156"></p><p><img src="https://picture.adagio-project.icu/pic/image-20230211203535763.png"></p></li><li><p>Dubbo写法</p><ol><li><p>将service服务和controller服务注册到zookeeper注册中心</p><p>service：</p><p><img src="https://picture.adagio-project.icu/pic/image-20230211204423133.png" alt="image-20230211204423133"></p><p>controller：</p><p><img src="https://picture.adagio-project.icu/pic/image-20230211204510742.png" alt="image-20230211204510742"></p></li><li><p>对UserServiceImpl代码进行修改，具体修改如下</p><p><img src="https://picture.adagio-project.icu/pic/image-20230211204307632.png" alt="image-20230211204307632"></p><p>注意，这里的Service注解不是Spring的注解，而是dubbo的注解</p></li><li><p>对UserController代码进行修改，具体操作如下</p><p><img src="https://picture.adagio-project.icu/pic/image-20230211204353978.png" alt="image-20230211204353978"></p></li><li><p>将Controller模块中对Service的依赖删除</p><p><img src="https://picture.adagio-project.icu/pic/image-20230211210445688.png" alt="image-20230211210445688"></p></li><li><p>此时Controller中会有找不到UserService的报错，我们只需要在Controller服务里创建一个全路径一样的接口就行了</p><p><img src="https://picture.adagio-project.icu/pic/image-20230211210615250.png" alt="image-20230211210615250"></p></li><li><p>然后就可以启动两个服务，调用并查看结果</p><p><img src="https://picture.adagio-project.icu/pic/image-20230211210709014.png" alt="image-20230211210709014"></p><p><img src="https://picture.adagio-project.icu/pic/image-20230211210739909.png" alt="image-20230211210739909"></p></li></ol></li><li><p>Dubbo写法升级</p><p>因为在实际开发中，我们不可能去协调两个服务开发部门让他们去协商接口叫什么名字，并且，这些接口既在Service服务中存在，也在Controller服务中存在，比较冗余，所以接下来我们会把这些接口给独立出来</p><ol><li><p>创建一个公共接口模块</p><p><img src="https://picture.adagio-project.icu/pic/image-20230211211534861.png" alt="image-20230211211534861"></p></li><li><p>让Controller和Service模块依赖于公共接口模块</p><p><img src="https://picture.adagio-project.icu/pic/image-20230211211633252.png" alt="image-20230211211633252"></p></li><li><p>删除Controller和Service中的接口</p></li><li><p>测试运行</p><p><img src="https://picture.adagio-project.icu/pic/image-20230211211922455.png" alt="image-20230211211922455"></p></li></ol></li></ul><h2 id="三-Dubbo高级特性"><a href="#三-Dubbo高级特性" class="headerlink" title="三.Dubbo高级特性"></a>三.Dubbo高级特性</h2><h3 id="dubbo-admin管理平台"><a href="#dubbo-admin管理平台" class="headerlink" title="dubbo-admin管理平台"></a>dubbo-admin管理平台</h3><ul><li><p>dubbo-admin作用</p><ol><li>dubbo-admin管理平台，是图形化的服务管理页面</li><li>从注册中心中获取到所有的提供者&#x2F;消费者进行配置管理</li><li>路由规则、动态配置、服务降级、访问控制、权重调整、负载均衡等管理功能</li></ol></li><li><p>dubbo-admin的安装</p><ol><li>dubbo-admin是一个前后端分离的项目。前端使用vue，后端使用springboot</li><li>安装dubbo-admin其实就是部署该项目</li></ol><p>具体流程如下：</p><ol><li><p>github上克隆dubbo-admin源码或者下载他的压缩包，随后解压</p><p><img src="https://picture.adagio-project.icu/pic/image-20230211221612558.png" alt="image-20230211221612558"></p></li><li><p>安装node.js(因为前端使用vue构建的，需要node.js)</p></li><li><p>进入配置文件修改zookeeper地址</p><p><img src="https://picture.adagio-project.icu/pic/image-20230211221958692.png" alt="image-20230211221958692"></p><p><img src="https://picture.adagio-project.icu/pic/image-20230211222023779.png" alt="image-20230211222023779"></p></li><li><p>在 dubbo-admin-develop 目录执行打包命令，mvn clean package</p><p><img src="https://picture.adagio-project.icu/pic/image-20230211222338863.png" alt="image-20230211222338863"></p></li><li><p>启动后端，切换目录到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dubbo-Admin-develop\dubbo-admin-distribution\target&gt;</span><br></pre></td></tr></table></figure><p>然后执行如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar .\dubbo-admin-0.1.jar</span><br></pre></td></tr></table></figure></li><li><p>启动前端，切换目录到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dubbo-admin-develop\dubbo-admin-develop\dubbo-admin-ui</span><br></pre></td></tr></table></figure><p>执行如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure></li><li><p>访问<a href="http://localhost:8081/">http://localhost:8081</a></p><p><img src="https://picture.adagio-project.icu/pic/image-20230212223943532.png" alt="image-20230212223943532"></p></li></ol></li></ul><h3 id="dubbo常用高级配置"><a href="#dubbo常用高级配置" class="headerlink" title="dubbo常用高级配置"></a>dubbo常用高级配置</h3><h4 id="1-序列化"><a href="#1-序列化" class="headerlink" title="1. 序列化"></a>1. 序列化</h4><p>众所周知，我们在java网络传输对象的过程中需要将对象进行序列化操作，把他转换成流对象进行传输，在dubbo的操作过程中，框架底层已经实现了对序列化反序列化的方法的封装，所以我们只需要给将被传输的对象的类实现Serializable接口就行。</p><p>当消费者A调用生产者B的方法，我们必须保证A和B都拥有对此对象类的依赖，所以我们可以将这种类当作公共模块抽离出来</p><p><img src="https://picture.adagio-project.icu/pic/image-20230212230912803.png" alt="image-20230212230912803"></p><ol><li>抽离公共模块，取名为dubbo_pojo</li></ol><p><img src="https://picture.adagio-project.icu/pic/image-20230212231310220.png" alt="image-20230212231310220"></p><ol start="2"><li><p>在这个模块里写一个User类（先不实现Serializable接口）</p><p><img src="https://picture.adagio-project.icu/pic/202302122326136.png" alt="image-20230212232637951"></p></li><li><p>在接口模块里写一个方法返回User对象，在Service里重写该方法，并在Controller模块里调用该方法</p></li><li><p>查看结果</p><p><img src="https://picture.adagio-project.icu/pic/202302122329916.png" alt="image-20230212232904881"></p><p><img src="https://picture.adagio-project.icu/pic/202302122329674.png" alt="image-20230212232925597"></p><p>可见是由于没有实现Serializable接口所导致的</p></li><li><p>让User类实现Serializable接口并查看结果</p><p><img src="https://picture.adagio-project.icu/pic/202302122330173.png" alt="image-20230212233036144"></p></li></ol><h4 id="2-地址缓存"><a href="#2-地址缓存" class="headerlink" title="2. 地址缓存"></a>2. 地址缓存</h4><p>思考这样一个问题，如果注册中心挂了，服务是否能正常访问</p><p>答案是可以，因为dubbo服务消费者在第一次调用时，会将服务提供方地址缓存到本地，以后在调用则不会访问注册中心。</p><p>此时我们关闭了zookeeper，但是还能实现远程调用</p><p><img src="https://picture.adagio-project.icu/pic/202302132030723.png" alt="image-20230213203050656"></p><p><img src="https://picture.adagio-project.icu/pic/202302132031386.png" alt="image-20230213203120361"></p><p>当服务提供者地址发生变化时，注册中心会通知服务消费者。</p><h4 id="3-超时与重试"><a href="#3-超时与重试" class="headerlink" title="3. 超时与重试"></a>3. 超时与重试</h4><ol><li><p>超时</p><ul><li>服务消费者在调用服务提供者的时候发生了阻塞、等待的情形，这个时候，服务消费者会一直等待下去。</li><li>在某个峰值时刻，大量的请求都在同时请求服务消费者，会造成线程的大量堆积，势必会造成雪崩。</li><li>dubbo利用超时机制来解决这个问题，设置一个超时时间，在这个时间段内，无法完成服务访问，则自动断开连接</li><li>使用timeout属性配置超时时间，默认值1000，单位毫秒。</li></ul><p><img src="https://picture.adagio-project.icu/pic/202302132035099.png" alt="image-20230213203507054"></p><p>我们可以在@Service或@Reference的注解内添加timeout属性，也可以在配置文件里面设置timeout的值</p><p><img src="https://picture.adagio-project.icu/pic/202302132040686.png" alt="image-20230213204007663"></p><p><img src="https://picture.adagio-project.icu/pic/202302132043564.png" alt="image-20230213204352531"></p><p><img src="https://picture.adagio-project.icu/pic/202302132044149.png" alt="image-20230213204423120"></p><p>下面写一个案例来测试一下超时</p><ol><li><p>首先设置超时时间和重试次数（以@Service举例）</p><p><img src="https://picture.adagio-project.icu/pic/202302132046163.png" alt="image-20230213204632135"></p></li><li><p>写一个测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTimeout</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试结果</p><p><img src="https://picture.adagio-project.icu/pic/202302132107460.png" alt="image-20230213210737259"></p><p>建议将timeout配置在服务方，因为服务方知道自己方法执行的大概时间，可以给出更合理的超时时间</p></li></ol></li><li><p>重试</p><ul><li>设置了超时时间，在这个时间段内，无法完成服务访问，则自动断开连接。</li><li>如果出现网络抖动，则这一次请求就会失败。</li><li>Dubbo提供重试机制来避免类似问题的发生。</li><li>通过retries属性来设置重试次数。默认为2次。</li></ul></li></ol><h4 id="4-多版本"><a href="#4-多版本" class="headerlink" title="4. 多版本"></a>4. 多版本</h4><p>灰度发布:当出现新功能时，会让一部分用户先使用新功能，用户反馈没问题时，再将所有用户迁移到新功能。</p><p><img src="https://picture.adagio-project.icu/pic/202302132147515.png" alt="image-20230213214757414"></p><p>dubbo中使用version属性来设置和调用同一个接口的不同版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(version = &quot;v1.0&quot;)</span><span class="comment">//老版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findUserById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;old...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(id,<span class="string">&quot;zmx&quot;</span>,<span class="string">&quot;921&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(version = &quot;v2.0&quot;)</span><span class="comment">//新版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl2</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findUserById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;new...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(id,<span class="string">&quot;zmx&quot;</span>,<span class="string">&quot;921&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在消费者端选择需要的版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">//@Reference(version = &quot;v1.0&quot;)</span></span><br><span class="line">    <span class="meta">@Reference(version = &quot;v2.0&quot;)</span><span class="comment">//选择需要的版本</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getUser&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findUserById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.findUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别调用v1.0和v2.0，结果分别打印了old和new，代表版本选择成功</p><p><img src="https://picture.adagio-project.icu/pic/202302132156286.png" alt="image-20230213215642240"></p><h4 id="5-负载均衡"><a href="#5-负载均衡" class="headerlink" title="5. 负载均衡"></a>5. 负载均衡</h4><p>当我们对某个服务提供者做了集群处理，那么调用哪个服务就是个问题，所以dubbo提供了负载均衡策略</p><p><img src="https://picture.adagio-project.icu/pic/202302132212550.png" alt="image-20230213221215506"></p><p>我们可以在消费者的@Reference注解里加一个loadBalance属性，在里面填写想要设置的负载均衡策略</p><p>负载均衡策略(4种)∶</p><ul><li>Random:按权重随机，默认值。按权重设置随机概率。</li><li>RoundRobin:按权重轮询。</li><li>LeastActive:最少活跃调用数，相同活跃数的随机。</li><li>ConsistentHash:一致性Hash，相同参数的请求总是发到同一提供者。</li></ul><p>ps：默认策略是随机策略，可在提供者端的@Service注解内添加weight属性来设置权重</p><h4 id="6-集群容错"><a href="#6-集群容错" class="headerlink" title="6. 集群容错"></a>6. 集群容错</h4><p>如果在集群模式中，在消费者调用提供者的过程中出现了错误，就需要调用容错机制</p><ol><li><p>调用方式：</p><p>在消费者的@Reference注解里加一个cluster属性，在里面填写想要设置的集群容错模式</p></li><li><p>集群容错模式：</p></li></ol><ul><li>Failover Cluster:失败重试。默认值。当出现失败，重试其它服务器，默认重试2次，使用retries配置。一般用于读操作，默认模式就是这个模式</li><li>Failfast Cluster :快速失败，只发起—次调用，失败立即报错。通常用于写操作。</li><li>Failsafe Cluster :失败安全，出现异常时，直接忽略。返回—个空结果。</li><li>Failback Cluster :失败自动恢复，后台记录失败请求，定时重发。</li><li>Forking Cluster :并行调用多个服务器，只要一个成功即返回</li><li>Broadcast Cluster :广播调用所有提供者，逐个调用，任意一台报错则报错。</li></ul><h4 id="7-服务降级"><a href="#7-服务降级" class="headerlink" title="7. 服务降级"></a>7. 服务降级</h4><p>当提供者服务器里部署了多个服务，如果服务器的负载过大，我们必须舍弃掉一些相对不太重要的服务，这就是服务降级</p><p><img src="https://picture.adagio-project.icu/pic/202302132230751.png" alt="image-20230213223033688"></p><p>在消费者的@Reference注解里加一个mock属性，在里面填写想要设置的服务降级方式</p><p>服务降级的方式：</p><ul><li>mock&#x3D;force:return null表示消费方对该服务的方法调用都直接返回null值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。</li><li>mock&#x3D;fail:return null表示消费方对该服务的方法调用在失败后，再返回null值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式学习笔记</title>
      <link href="/2022/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式的目的"><a href="#设计模式的目的" class="headerlink" title="设计模式的目的"></a>设计模式的目的</h2><p>编写软件过程中，程序员面临着来自耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性等多方面的挑战，设计模式是为了让程序(软件)，具有更好的</p><p>1.代码重用性（即：相同功能的代码，不用多次编写)</p><p>2.可读性（即：编程规范性，便于其他程序员的阅读和理解）</p><p>3.可扩展性（即：当需要增加新的功能时，非常的方便，称为可维护）</p><p>4.可靠性(即：当我们增加新的功能后，对原来的功能没有影响）</p><p>5.使程序呈现高内聚，低耦合的特性</p><h3 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h3><h4 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1.单一职责原则"></a>1.单一职责原则</h4><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>对类来说的，即一个类应该只负责一项职责。如类A负责两个不同职责：职责1，职责2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1，A2</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>1.降低类的复杂度，一个类只负责一项职责。</p><p>2.提高类的可读性，可维护性</p><p>3.降低变更引起的风险</p><p>4.通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则：只有类中方法数量足够少，可以在方法级别保持单一职责原则</p><h4 id="2-接口隔离原则"><a href="#2-接口隔离原则" class="headerlink" title="2.接口隔离原则"></a>2.接口隔离原则</h4><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</p><h4 id="3-依赖倒转（倒置）原则"><a href="#3-依赖倒转（倒置）原则" class="headerlink" title="3.依赖倒转（倒置）原则"></a>3.依赖倒转（倒置）原则</h4><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>1.高层模块不应该依赖低层模块，二者都应该依赖其抽象</p><p>2.抽象不应该依赖细节，细节应该依赖抽象</p><p>3.依赖倒转（倒置）的中心思想是面向接口编程</p><p>4.依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细出节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类</p><p>5.使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</p><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>1.低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好</p><p>2.变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化</p><p>3.继承时遵循里氏替换原则</p><h4 id="4-里氏替换原则"><a href="#4-里氏替换原则" class="headerlink" title="4.里氏替换原则"></a>4.里氏替换原则</h4><p>1.如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。</p><p>2.在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法</p><p>3.里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。</p><h4 id="5-开闭原则"><a href="#5-开闭原则" class="headerlink" title="5.开闭原则"></a>5.开闭原则</h4><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>1.开闭原则（Open Closed Principle）是编程中最基础、最重要的设计原则</p><p>2.一个软件实体如类，模块和函数应该对扩展开放，对修改关闭。用抽象构建框架用实现扩展细节。</p><p>3.当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p><p>4.编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</p><h4 id="6-迪米特法则"><a href="#6-迪米特法则" class="headerlink" title="6.迪米特法则"></a>6.迪米特法则</h4><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p>1.一个对象应该对其他对象保持最少的了解</p><p>2.类与类关系越密切，耦合度越大</p><p>3.迪米特法则(Demeter Principle)又叫最少知道原则， 即一个类对自已依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public 方法，不对外泄露任何信息</p><p>4.迪米特法则还有个更简单的定义：只写直接的朋友通信</p><p>5.直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</p><h4 id="7-合成复用原则"><a href="#7-合成复用原则" class="headerlink" title="7.合成复用原则"></a>7.合成复用原则</h4><h4 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h4><p>原则是尽量使用合成&#x2F;聚合的方式，而不是使用继承</p><h3 id="设计原则的核心思想"><a href="#设计原则的核心思想" class="headerlink" title="设计原则的核心思想"></a>设计原则的核心思想</h3><p>1.找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</p><p>2.针对接口编程，而不是针对实现编程。</p><p>3.为了交互对象之间的松耦合设计而努力</p><h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><h4 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h4><ol><li>UML–Unified modeling language UML统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果</li><li>UML本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等</li><li>使用UML来建模，常用的工具有 RationalRose，也可以使用一些插件来建模</li></ol><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>1.用例图(usecase)</p><p>2.静态结构图：类图、对象图、包图、组件图、部署图</p><p>3.动态行为图：交互图（时序图与协作图）、状态图、活动图</p><h4 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h4><p><strong>依赖</strong>：只要是在类中用到了对方，那么他们之间就存在依赖关系，如果没有对方，编译都无法通过</p><p><strong>泛化（继承）</strong>：泛化关系实际上就是继承关系，他是依赖关系的特例</p><p><strong>实现</strong>：实现关系实际上就是A类实现了B类，他是依赖关系的特例</p><p><strong>关联</strong>：</p><p>1.关联关系实际上就是类与类之间的联系，他是依赖关系的特例<br>2.关联具有导航性：即双向关系或单向关系<br>3.关系具有多重性：如“1”（表示有且仅有一个），“0.”（表示0个或者多个），“0，1”（表示0个或者一个），“n…m”(表示n到m个都可以)”m…*”（表示至少m个）。</p><p><strong>聚合</strong>：表示整体和部分的关系，整体与部分可以分开，聚合关系是关联关系的特例，所以他具有关联的导航性和多重性</p><p><strong>组合</strong>：和聚合的区别就是，组合关系的整体和部分不可以分开</p><h2 id="掌握设计模式的层次"><a href="#掌握设计模式的层次" class="headerlink" title="掌握设计模式的层次"></a>掌握设计模式的层次</h2><p>第1层：刚开始学编程不久，听说过什么是设计模式</p><p>第2层：有很长时间的编程经验，自已写了很多代码，其中用到了设计模式，但是自己却不知道</p><p>第3层：学习过了设计模式，发现自已已经在使用了，并且发现了一些新的模式挺好用的</p><p>第4层：阅读了很多别人写的源码和框架，在其中看到别人设计模式，并且能够领会设计模式的精妙和带来的好处。</p><p>第5层：代码写着写着，自已都没有意识到使用了设计模式，并且熟练的写了出来。</p><h2 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h2><p>设计模式分为三种类型，共23种</p><p>1.创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式</p><p>2.结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。</p><p>3.行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)</p><h2 id="一句话介绍23种设计模式"><a href="#一句话介绍23种设计模式" class="headerlink" title="一句话介绍23种设计模式"></a>一句话介绍23种设计模式</h2><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><p>创建型模式简单来说就是用来创建对象的。一共有五种：单例模式、建造者模式、工厂方法模式、抽象工厂模式、原型模式。</p><ol><li>单例模式 ：确保某一个类只有一个实例，并且提供一个全局访问点。</li><li>建造者模式 ： 封装非常复杂的实例化过程，通常有一个导向器和构造器。</li><li>工厂方法模式 ：将实例化时间延迟到子类，子类应用自动实例化不同的实例。</li><li>抽象工厂模式 ：它主要强调实例化一系列的各种各样的产品，不同系列的产品构造由不同的子类产生，构造各种产品的接口作为一个父类。</li><li>原型模式 ：当一个组合对象被实例化的时候，这个对象是个非常复杂而且功能是由运行时刻决定的，现在要把这个对象实例当做一个原型单位进行使用，每个对象都实现一个clone操作，这样就可以减少整个系统的类数目。</li></ol><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><p>行为型模式主要是描述类或者对象是怎样交互和怎样分配职责的。</p><p>一共有十一种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><ol><li>策略模式 ：对于某个核心算法进行封装，这个算法会经常被修改，这就需要把算法的接口抽象出来，子类来实现具体的算法过程。</li><li>状态模式 ：各种状态的操作都不同，这就会在一个方法中出现很多分支流程，这时候使用状态模式非常有用，也便于理解；将对象的不同状态分割成不同的状态对象。</li><li>责任链模式 ：将消息的发送者和接受者解耦，发送者就往责任链上随便已发就完事，它不管哪个对象去实现这个消息，消息沿着链接传递直到被处理或者被丢弃；这个链可以通过继承关系或引用关系来实现。</li><li>观察者模式 ：将数据和视图分开，通常一个 subject 被多个观察这观察，这些观察者会实现 update 操作，subject 都会实现 notify 操作。</li><li>模板方法模式 ：就是父类定义了各个接口的调用顺序，而各个接口需要子类重新定义，这样就是同一套流程实现了不同的操作。</li><li>迭代器模式 ：提供一种顺序方位各种对象的模式，通常需要使用template技术实现。</li><li>备忘录模式 ：有些命令需要撤销，这就需要把对象的某些变化状态保存在一个备忘录对象中，当需要恢复时取出备忘录中保存的历史状态。</li><li>访问者模式 ：对每个对象定义一个接口，原发器将自身作为参数传递给visitor子类，这样可以在不改变类系统结构的情况下自由添加新的功能，但是这种模式不适用于对象系统中对象经常变化的场合，每次对象变化可能都需要把所有的vsitor子类修改一遍。</li><li>中介者模式 ：减少各个对象之间的交互，将交互的责任集中在一个中介对象中，有点类似与 Facade 模式。</li><li>解释器模式 ：主要是针对某一种发明的语言或者协议，一般都会生成一个语法树，同时对分析结果使用buider模式实例化对象。</li><li>命令模式 ：将消息封装在一个对象中，这消息对象指定接受者，这个消息对象可以通过责任链或者消息队列来存放。</li></ol><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><p>结构型模式主要是用于处理类或者对象的组合。一共有七种：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><ol><li>代理模式 ：将一些复杂的过程委托给一个独立的对象去处理，只需将this指针作为参数设置到代理对象，然后调用简单的接口即可实现很复杂的过程。</li><li>组合模式 ：一个系统中各种对象存在树形结构或者有向无环图结构就应该使用这种模式，使得部分和整体的操作都一样。</li><li>适配器模式 ：某个类已经投入使用中不可进行改变，另一个类与这个类比较类似，通过继承适配者类，引用被适配的类，然后通过之被适配者的功能来实现适配者父类的接口；如果需要双向适配就使用多继承的方法。</li><li>装饰者模式 ：在一个系统的外层来修饰它的功能，让client没有感觉就完成功能的添加，从类图上看就是对原系统的一个包裹。</li><li>享元模式 ：系统中有很多小对象，这些小对象会重复量非常大，浪费特别多的存储开销，这时候就需要使用Flyweight来共享对象，节约存储开销。</li><li>外观模式 ：把一个复杂的子系统整合起来封装到一个类中，使得常用的接口统一在这个类中，这样可以让各个子系统关系更加清晰。</li><li>桥接模式 ：发现一个系统中有两个独立变化的部分，业务逻辑和底层实现是不同的变化层次，这时候就需要把底层实现独立出来，用一个桥接类接口独立它们的变化。</li></ol><h2 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h2><h4 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h4><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="单例模式有八种方式："><a href="#单例模式有八种方式：" class="headerlink" title="单例模式有八种方式："></a>单例模式有八种方式：</h5><h5 id="1-饿汉式（静态常量）"><a href="#1-饿汉式（静态常量）" class="headerlink" title="1.饿汉式（静态常量）"></a>1.饿汉式（静态常量）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">//1.构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//2，本类内部创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">//3.提供公有静态方法，返回实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点说明：</p><p>1.优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</p><p>2.缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费</p><p>3.这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大多数都是调用getlnstance方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance就没有达到lazyloading的效果</p><p>4.结论：这种单例模式可用，可能造成内存浪费</p><h5 id="2-饿汉式（静态代码块）"><a href="#2-饿汉式（静态代码块）" class="headerlink" title="2.饿汉式（静态代码块）"></a>2.饿汉式（静态代码块）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">//1.构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//2，本类内部创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance;</span><br><span class="line">    <span class="keyword">static</span> &#123;<span class="comment">//在静态代码块中创建实例对象</span></span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.提供公有静态方法，返回实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点说明：</p><p>1.这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的</p><p>2.结论：这种单例模式可用，但是可能造成内存浪费</p><h5 id="3-懒汉式（线程不安全）"><a href="#3-懒汉式（线程不安全）" class="headerlink" title="3.懒汉式（线程不安全）"></a>3.懒汉式（线程不安全）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，当使用该方法时才去创建instance</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点说明：</p><p>1.起到了LazyLoading的效果，但是只能在单线程下使用。</p><p>2.如果在多线程下，一个线程进入了if(singleton&#x3D;&#x3D;null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式</p><p>3.结论：在实际开发中，不要使用这种方式</p><h5 id="4-懒汉式（线程安全，同步方法）"><a href="#4-懒汉式（线程安全，同步方法）" class="headerlink" title="4.懒汉式（线程安全，同步方法）"></a>4.懒汉式（线程安全，同步方法）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//加入了synchronized关键字实现线程安全</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点说明：</p><p>1.解决了线程不安全问题</p><p>2.效率太低了，每个线程在想获得类的实例时候，执行getinstance0方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例直接return就行了。方法进行同步效率太低</p><p>3.结论：在实际开发中，不推荐使用这种方式</p><h5 id="5-懒汉式（线程安全，同步代码块）"><a href="#5-懒汉式（线程安全，同步代码块）" class="headerlink" title="5.懒汉式（线程安全，同步代码块）"></a>5.懒汉式（线程安全，同步代码块）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;<span class="comment">//synchronized加在这里并不能保证线程安全</span></span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点说明：</p><p>1.这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低，改为同步产生实例化的的代码块</p><p>2.但是这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一致，假如一个线程进入了if(singleton &#x3D;&#x3D;null)判断语句块，还</p><p>未来得及往下执行另一个线程也通过了这个判断语句，这时便会产生多个实例</p><p>3.结论：在实际开发中，不能使用这种方式</p><h5 id="6-双重检查"><a href="#6-双重检查" class="headerlink" title="6.双重检查"></a>6.双重检查</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"><span class="comment">//加入了双重检查代码，解决了线程安全问题，同时解决了懒加载问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点说明：</p><p>1.Double-Check概是多线程开发中常使用到的，如代码中所示，我们进行了两次if (singleton&#x3D;&#x3D;null)检查，这样就可以保证线程安全了。</p><p>2.这样，实例化代码只用执行一次，后面再次访问时，判断if(singleton &#x3D;&#x3D; null);直接return实例化对象，也避免的反复进行方法同步</p><p>3.线程安全：延迟加载；效率较高</p><p>4.结论：在实际开发中，推荐使用这种单例设计模式</p><h5 id="7-静态内部类"><a href="#7-静态内部类" class="headerlink" title="7.静态内部类"></a>7.静态内部类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//公有静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点说明：</p><p>1.这种方式采用了类装载的机制来保证初始化实例时只有一个线程。</p><p>2.静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getlnstance方法，才会装载Singletonlnstance类，从而完成Singleton的实例化。</p><p>3.类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</p><p>4.优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</p><p>5.结论：推荐使用</p><h5 id="8-枚举"><a href="#8-枚举" class="headerlink" title="8.枚举"></a>8.枚举</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点说明：</p><p>1.这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。</p><p>2.这种方式是EffectiveJava作者JoshBloch提倡的方式</p><p>3.结论：推荐使用</p><h4 id="单例模式在JDK中的使用之一"><a href="#单例模式在JDK中的使用之一" class="headerlink" title="单例模式在JDK中的使用之一"></a>单例模式在JDK中的使用之一</h4><p><img src="https://picture.adagio-project.icu/pic/202308092238108.png" alt="image-20230809223819812"></p><p>可见这是一个饿汉式的单例模式</p><h4 id="单例模式注意事项和细节说明"><a href="#单例模式注意事项和细节说明" class="headerlink" title="单例模式注意事项和细节说明"></a>单例模式注意事项和细节说明</h4><p>1.单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能</p><p>2.当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new</p><p>3.单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多（即：重量级对象），但文经常用到的对象、工具类对象、频繁访问数据库或文件的对象（比如数据源、session工厂等）</p><h2 id="2-工厂设计模式"><a href="#2-工厂设计模式" class="headerlink" title="2.工厂设计模式"></a>2.工厂设计模式</h2><h4 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1.简单工厂模式"></a>1.简单工厂模式</h4><h5 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h5><p>1.简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式</p><p>2.简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为（代码）</p><p>3.在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式</p><h4 id="2-工厂方法模式"><a href="#2-工厂方法模式" class="headerlink" title="2.工厂方法模式"></a>2.工厂方法模式</h4><h5 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h5><p>定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到了子类</p><h4 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="3.抽象工厂模式"></a>3.抽象工厂模式</h4><h5 id="介绍-10"><a href="#介绍-10" class="headerlink" title="介绍"></a>介绍</h5><p>1.抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象族，而无需指明具体的类</p><p>2.抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。</p><p>3.从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象）</p><p>4.将工厂抽象成两层，AbsFactory(抽象工厂）和具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇更利于代码的维护和扩展。</p><h4 id="工厂模式在JDK的使用之一"><a href="#工厂模式在JDK的使用之一" class="headerlink" title="工厂模式在JDK的使用之一"></a>工厂模式在JDK的使用之一</h4><p>Calendar类的静态方法getInstance</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> createCalendar(TimeZone.getDefault(), Locale.getDefault(Locale.Category.FORMAT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中createCalendar方法的部分代码如下</p><p><img src="https://picture.adagio-project.icu/pic/image-20221121005032568.png"></p><p>显然这是一个简单工厂模式，通过switch来判断到底实例化哪一个类</p><h4 id="工厂模式细节说明"><a href="#工厂模式细节说明" class="headerlink" title="工厂模式细节说明"></a>工厂模式细节说明</h4><p>1.工厂模式的意义是将实例化对象的代码提取出来，放到一个类中统一管理和维维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。</p><p>2.三种工厂模式（简单工厂模式、工厂方法模式、抽象工厂模式</p><p>3.设计模式的依赖抽象原则</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>1.创建对象实例时，不要直接 new 类，而是把这个new 类的动作放在一个工厂的方法中，并返回。有的书上说，变量不要直接持有具体类的引用。</p><p>2.不要让类继承具体类，而是继承抽象类或者是实现interface(接口)</p><p>3.不要覆盖基类中已经实现的方法。</p><h2 id="3-原型模式"><a href="#3-原型模式" class="headerlink" title="3.原型模式"></a>3.原型模式</h2><h5 id="介绍-11"><a href="#介绍-11" class="headerlink" title="介绍"></a>介绍</h5><p>1.原型模式(Prototype模式)是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象</p><p>2.原型模式是一和创建型设计模式，允许一个对象再创建另外一个可定制的对象无需知道如何创建的细节</p><p>3.工作原理是通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自已来实施创建，即对象.clone()</p><h4 id="原型模式在Spring中的运用"><a href="#原型模式在Spring中的运用" class="headerlink" title="原型模式在Spring中的运用"></a>原型模式在Spring中的运用</h4><p>在 Spring 中原型 bean 的创建，就是使用得原型模式</p><p>比如下面的bean配置</p><bean id="sheep" class="com.java.springtest.prototype.Sheep" scope="prototype"/><p>scope可以选singleton（单例）和prototype（原型）</p><p>当我们调用getBean获取bean时，会跳转到AbstractApplicationContext 类的 getBean() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="built_in">this</span>.assertBeanFactovActive();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getBeanFactory().getBean(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这我们还看不出是否用了原型模式，接着往下看，调用了doGetBean方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.doGetBean(name,(Class)<span class="literal">null</span>,(Object)<span class="literal">null</span>,<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来到doGetBean方法里面，有这么一段代码</p><p><img src="https://picture.adagio-project.icu/pic/image-20221121182039192.png" alt="image-20221121182039192"></p><p><img src="https://picture.adagio-project.icu/pic/image-20221121182103852.png" alt="image-20221121182103852"></p><p>显然我们用的时prototype，不会进入if语句，会进入else if语句，然后里面使用了原型模式来创建实例</p><h4 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h4><h5 id="浅拷贝介绍"><a href="#浅拷贝介绍" class="headerlink" title="浅拷贝介绍"></a>浅拷贝介绍</h5><p>1.对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。</p><p>2.对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值</p><p>3.浅拷贝是使用默认的clone()方法来实现</p><h5 id="深拷贝介绍"><a href="#深拷贝介绍" class="headerlink" title="深拷贝介绍"></a>深拷贝介绍</h5><p>1.复制对象的所有基本数据类型的成员变量值</p><p>2.为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象进行拷贝</p><p>3.深拷贝实现方式1：重写clone方法来实现深拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">deep</span> <span class="operator">=</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    <span class="type">DeepPrototype</span> <span class="variable">deepPrototype</span> <span class="operator">=</span> (DeepPrototype) deep;</span><br><span class="line">    <span class="type">DeepPrototypeTarget</span> <span class="variable">target1</span> <span class="operator">=</span>(DeepPrototypeTarget) deepPrototype.getTarget().clone();</span><br><span class="line">    deepPrototype.setTarget(target1);</span><br><span class="line">    <span class="keyword">return</span> deepPrototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.深拷贝实现方式2：通过对象序列化实现深拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    ByteArrayOutputStream bos;</span><br><span class="line">    ByteArrayInputStream bis;</span><br><span class="line">    ObjectInputStream ois;</span><br><span class="line">    ObjectOutputStream oos;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        bos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        bis = <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());</span><br><span class="line">        ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">        <span class="keyword">return</span> ois.readObject();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="原型模式的细节"><a href="#原型模式的细节" class="headerlink" title="原型模式的细节"></a>原型模式的细节</h5><p>1.创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率</p><p>2.不用重新初始化对象，而是动态地获得对象运行时的状态</p><p>3.如果原始对象发生变化（增加或者减少属性），其它克隆对象的也会发生相应的变化无需修改代码</p><p>4.在实现深克隆的时候可能需要比较复杂的代码</p><p>5.缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了ocp原则</p><h2 id="4-建造者模式"><a href="#4-建造者模式" class="headerlink" title="4.建造者模式"></a>4.建造者模式</h2><h5 id="介绍-12"><a href="#介绍-12" class="headerlink" title="介绍"></a>介绍</h5><p>1.建造者模式（BuilderPattern）又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</p><p>2.建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</p><h5 id="建造者模式的四个角色"><a href="#建造者模式的四个角色" class="headerlink" title="建造者模式的四个角色"></a>建造者模式的四个角色</h5><p>1.Product（产品角色）：一个具体的产品对象。</p><p>2.Builder（抽象建造者）：创建一个Product对象的各个部件指定的接口&#x2F;抽象类</p><p>3.ConcreteBuilder（具体建造者）：实现接口，构建和装配各个部件。</p><p>4.Director（指挥者）：构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。</p><h5 id="建造者模式原理类图"><a href="#建造者模式原理类图" class="headerlink" title="建造者模式原理类图"></a>建造者模式原理类图</h5><p><img src="https://picture.adagio-project.icu/pic/image-20221122104825218.png" alt="image-20221122104825218"></p><h5 id="建造者模式在JDK中的应用"><a href="#建造者模式在JDK中的应用" class="headerlink" title="建造者模式在JDK中的应用"></a>建造者模式在JDK中的应用</h5><p>源码中建造者模式角色分析</p><p>1.Appendable 接口定义了多个append方法(抽象方法)，即Appendable 为抽象建造者，定义了抽象方法</p><p>2.AbstractStringBuilder 实现了Appendable接口方法，这里的AbstractStringBuilder已经是建造者，只是不能实例化</p><p>3.StringBuilder即充当了指挥者角色，同时充当了具体的建造者，建造方法的实现是由AbstractStringBuilder 完成，而StringBuilder 继承了AbstractStringBuilder</p><h5 id="建造者模式使用细节"><a href="#建造者模式使用细节" class="headerlink" title="建造者模式使用细节"></a>建造者模式使用细节</h5><p>1.客户端（使用程序）不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</p><p>2.每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象</p><p>3.可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方律使用程序来控制创建过程</p><p>4.增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程系统扩展方便，符合“开闭原则”</p><p>5.建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</p><p>6.如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式</p><p>7.抽象工厂模式VS建造者模式：抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品</p><h2 id="5-适配器模式"><a href="#5-适配器模式" class="headerlink" title="5.适配器模式"></a>5.适配器模式</h2><h5 id="介绍-13"><a href="#介绍-13" class="headerlink" title="介绍"></a>介绍</h5><p>1.适配器模式(AdapterPattern)将某个类的接口转换成客户端期望的另一个接口表示，主的自的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper）</p><p>2.适配器模式属于结构型模式</p><p>3.主要分为三类：类适配器模式、对象适配器模式、接口适配器模式</p><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p>1.适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容</p><p>2.从用户的角度看不到被适配者，是解耦的</p><p>3.用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法</p><p>4.用户收到反馈结果，感觉只是和自标接口交互，如图</p><p><img src="https://picture.adagio-project.icu/pic/image-20221123135100072.png" alt="image-20221123135100072"></p><h5 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h5><h5 id="1-类适配器"><a href="#1-类适配器" class="headerlink" title="1.类适配器"></a>1.类适配器</h5><p>基本介绍：Adapter类，通过继承src类，实现dst类接口，完成src-&gt;dst的适配</p><p>类适配器的注意事项：</p><p>1.Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点，因为这要求dst必须是接口，有一定局限性；</p><p>2.src类的方法在Adapter中都会暴露出来，也增加了使用的成本。</p><p>3.由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了。</p><h5 id="2-对象适配器"><a href="#2-对象适配器" class="headerlink" title="2.对象适配器"></a>2.对象适配器</h5><p>基本介绍：</p><p>1.基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而是持有src类的实例，以解决兼容性的问题。即：持有src类，实现dst类接口，完成src-&gt;dst的适配</p><p>2.根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系。</p><p>3.对象适配器模式是适配器模式常用的一种</p><p>对象适配器的注意事项：</p><p>1.对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。根据合成复用原则，使用组合替代继承，所以它解决了类适配器必须继承src的局限性问题，也不再要求dst必须是接口。</p><p>2.使用成本更低，更灵活。</p><h5 id="3-接口适配器"><a href="#3-接口适配器" class="headerlink" title="3.接口适配器"></a>3.接口适配器</h5><p>基本介绍：</p><p>1.一些书籍称为：适配器模式（DefaultAdapterPattern）或缺省适配器模式。</p><p>2.当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求</p><p>3.适用于一个接口不想使用其所有的方法的情况。</p><h5 id="适配器模式在SpringMVC中的运用"><a href="#适配器模式在SpringMVC中的运用" class="headerlink" title="适配器模式在SpringMVC中的运用"></a>适配器模式在SpringMVC中的运用</h5><p>SpringMVC中的HandlerAdapter就用了适配器模式，具体流程如下图</p><p><img src="https://picture.adagio-project.icu/pic/image-20221123172253550.png" alt="image-20221123172253550"></p><h5 id="适配器模式的注意细节"><a href="#适配器模式的注意细节" class="headerlink" title="适配器模式的注意细节"></a>适配器模式的注意细节</h5><p>1.三种命名方式，是根据 src是以怎样的形式给到Adapter（在Adapter里的形式）来命名的。</p><ol start="2"><li></li></ol><p>类适配器：以类给到，在Adapter里，就是将src当做类，继承<br>对象适配器：以对象给到，在Adapter里，将src作为一个对象，持有<br>接口适配器：以接口给到，在Adapter里，将src作为一个接口，实现</p><p>3.Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作。</p><p>4.实际开发中，实现起来不拘泥于我们讲解的三种经典形式</p><h2 id="6-桥接模式"><a href="#6-桥接模式" class="headerlink" title="6.桥接模式"></a>6.桥接模式</h2><h3 id="介绍-14"><a href="#介绍-14" class="headerlink" title="介绍"></a>介绍</h3><ol><li>桥接模式(Bridge模式)是指：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。</li><li>是一种结构型设计模式</li><li>Bridge模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。 它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展</li></ol><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://picture.adagio-project.icu/pic/image-20221124142733549.png" alt="image-20221124142733549"></p><h3 id="类图说明"><a href="#类图说明" class="headerlink" title="类图说明"></a>类图说明</h3><ol><li>Client类：桥接模式的调用者</li><li>抽象类（Abstraction）维护了lmplementor&#x2F;即它的实现类ConcreteImplementorA..二者是聚合关系，Abstraction充当桥接类</li><li>RefinedAbstraction：是Abstraction抽象类的子类</li><li>implementor：行为实现类的接口</li><li>ConcretelmplementorA&#x2F;B：行为的具体实现类</li><li>从UML图：这里的抽象类和接口是聚合的关系，其实调用和被调用关系</li></ol><h3 id="JDBC源码使用的桥接模式"><a href="#JDBC源码使用的桥接模式" class="headerlink" title="JDBC源码使用的桥接模式"></a>JDBC源码使用的桥接模式</h3><p><img src="https://picture.adagio-project.icu/pic/image-20221124151452595.png" alt="image-20221124151452595"></p><p>如图所示，左边为接口，右边为桥，和典型的桥接模式不同的是，右边没有用抽象类，而是直接用普通类来调用接口方法</p><h3 id="桥接模式注意及细节"><a href="#桥接模式注意及细节" class="headerlink" title="桥接模式注意及细节"></a>桥接模式注意及细节</h3><ol><li>实现了抽象和实现部分的分离，从而极天的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。</li><li>对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。</li><li>桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。</li><li>桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程</li><li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性，即需要有这样的应用场景。</li></ol><h3 id="桥接模式及其应用场景"><a href="#桥接模式及其应用场景" class="headerlink" title="桥接模式及其应用场景"></a>桥接模式及其应用场景</h3><p>对于那些不希望使用继承或因为多层次继承导致系统类的入数急剧增加的系统，桥接模式尤为适用<br>常见的应用场景：</p><pre><code> 1. JDBC驱动程序 1.  银行转账系统         转账分类：网上转账，柜台转账，ATM转账         转账用户类型：普通用户，银卡用户，金卡用户 1. 消息管理         消息类型：即时消息，延时消息         消息分类：手机短信，邮件消息，QQ消息...</code></pre><h2 id="7-装饰者模式"><a href="#7-装饰者模式" class="headerlink" title="7.装饰者模式"></a>7.装饰者模式</h2><h3 id="介绍-15"><a href="#介绍-15" class="headerlink" title="介绍"></a>介绍</h3><p>装饰者模式:动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则(ocp)</p><h3 id="装饰者模式在JDK中的运用"><a href="#装饰者模式在JDK中的运用" class="headerlink" title="装饰者模式在JDK中的运用"></a>装饰者模式在JDK中的运用</h3><p>例如：</p><p>InputStream是抽象类，FileInputStream是InputStream的子类，BufferedInputStream是FilterInputStream的子类，是具体修饰者，FilterInputStream类有protected volatile InputStream in，即包含被装饰者</p><h2 id="8-组合模式"><a href="#8-组合模式" class="headerlink" title="8.组合模式"></a>8.组合模式</h2><h3 id="介绍-16"><a href="#介绍-16" class="headerlink" title="介绍"></a>介绍</h3><ol><li>组合模式(Composite Pattern)，又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“整体-部分”的层次关系。</li><li>组合模式依据树形结构来组合对象，用来表示部分以及整体层次。</li><li>这种类型的设计模式属于结构型模式。</li><li>组合模式使得用户对单个对象和组合对象的访问具有一致性，即:组合能让客户以一致的方式处理个别对象以及组合对象</li></ol><h3 id="原理结构说明"><a href="#原理结构说明" class="headerlink" title="原理结构说明"></a>原理结构说明</h3><ol><li>Component :这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为,用于访问和管理Component子部件,Component可以是抽象类或者接口</li><li>Leaf:在组合中表示叶子节点,叶子节点没有子节点</li><li>Composite :非叶子节点，用于存储子部件，在Component接口中实现子部件的相关操作，比如增加、删除</li></ol><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><ol><li>组合模式解决这样的问题，当我们的要处理的对象可以生成一颗树形结构，而我们要对树上的节点和叶子进行操作时，它能够提供一致的方式，而不用考虑它是节点还是叶子</li><li>对应示意图</li></ol><p>​  <img src="https://picture.adagio-project.icu/pic/image-20221126145407276.png" alt="image-20221126145407276"></p><h3 id="组合模式在HashMap中的运用"><a href="#组合模式在HashMap中的运用" class="headerlink" title="组合模式在HashMap中的运用"></a>组合模式在HashMap中的运用</h3><ol><li>Map就是一个抽象的构建（类似我们的Component)</li><li>HashMap是一个中间的构建(Composite)，实现&#x2F;继承了相关方法put, putall</li><li>Node 是 HashMap的静态内部类,类似Leaf叶子节点,这里就没有put putall  ,  static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;</li></ol><h3 id="组合模式的注意事项"><a href="#组合模式的注意事项" class="headerlink" title="组合模式的注意事项"></a>组合模式的注意事项</h3><ol><li>简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题。</li><li>具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动.</li><li>方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构</li><li>需要遍历组织结构，或者处理的对象具有树形结构时，非常适合使用组合模式.</li><li>要求较高的抽象性,如果节点和叶子有很多差异性的话,比如很多方法和属性都不一样，不适合使用组合模式</li></ol><h2 id="9-外观模式"><a href="#9-外观模式" class="headerlink" title="9.外观模式"></a>9.外观模式</h2><h3 id="介绍-17"><a href="#介绍-17" class="headerlink" title="介绍"></a>介绍</h3><ol><li><p>外观模式(Facade)，也叫“过程模式:外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</p></li><li><p>外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节</p></li><li><p>类图如下</p><p><img src="https://picture.adagio-project.icu/pic/image-20221127162907824.png" alt="image-20221127162907824"></p></li></ol><h3 id="外观模式在MyBatis中的运用"><a href="#外观模式在MyBatis中的运用" class="headerlink" title="外观模式在MyBatis中的运用"></a>外观模式在MyBatis中的运用</h3><p><img src="https://picture.adagio-project.icu/pic/image-20221127162239575.png" alt="image-20221127162239575"></p><p>如上展示的类图，Configuration为外观类，管理下面的子系统类，客户端只需要调用Configurtion的newMetaObject方法就可以获得MetaObject，而无需自己调用子系统方法</p><h3 id="外观模式的注意事项"><a href="#外观模式的注意事项" class="headerlink" title="外观模式的注意事项"></a>外观模式的注意事项</h3><ol><li>外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性</li><li>外观模式对客户端与子系统的耦合关系，让子系统内部的模块更易维护和扩展通过合理的使用外观模式，可以帮我们更好的划分访问的层次</li><li>当系统需要进行分层设计时，可以考虑使用Facade模式</li><li>在维护一个遗留的大型系统时，可能这个系统经发停非吊4以箭单的接可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口，让新系统与Facade类交互，提高复用性</li><li>不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以让系统有层次，利于维护为目的。</li></ol><h2 id="10-享元模式"><a href="#10-享元模式" class="headerlink" title="10.享元模式"></a>10.享元模式</h2><h3 id="介绍-18"><a href="#介绍-18" class="headerlink" title="介绍"></a>介绍</h3><ol><li>享元模式( Flyweight Pattern）也叫蝇量模式:运用共享技术有效地支持大量细粒度的对象</li><li>常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个</li><li>享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率</li><li>享元模式经典的应用场景就是池技术了，String常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式</li></ol><h3 id="原理类图"><a href="#原理类图" class="headerlink" title="原理类图"></a>原理类图</h3><p><img src="https://picture.adagio-project.icu/pic/image-20221128102123737.png" alt="image-20221128102123737"></p><ol><li>FlyWeight是抽象的享元角色，他是产品的抽象类，同时定义出对象的外部状态和内部状态(后面介绍)的接口或实现</li><li>ConcreteFlyWeight是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务</li><li>UnSharedConcreteFlyWeight是不可共享的角色，一般不会出现在享元工厂</li><li>FlyWeightFactory享元工厂类，用于构建一个池容器(集合)，同时提供从池中获取对象方法</li></ol><h3 id="内部状态和外部状态"><a href="#内部状态和外部状态" class="headerlink" title="内部状态和外部状态"></a>内部状态和外部状态</h3><p>比如围棋、五子棋、跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一点，所以棋子颜色就是棋子的内部状态;而各个棋子之间的差别就是位置的不同，当我们落子后，落子颜色是定的，但位置是变化的，所以棋子坐标就是棋子的外部状态</p><ol><li>享元模式提出了两个要求:细粒度和共享对象。这里就涉及到内部状态和外部状态了，即将对象的信息分为两个部分:内部状态和外部状态</li><li>内部状态指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变</li><li>外部状态指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。</li><li>举个例子:围棋理论上有361个空位可以放棋子，每盘棋都有可能有两三百个棋子对象产生，因为内存空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解决了对象的开销问题</li></ol><h3 id="享元模式在JDK中的使用"><a href="#享元模式在JDK中的使用" class="headerlink" title="享元模式在JDK中的使用"></a>享元模式在JDK中的使用</h3><p>在Integer类的源码中有用到享元模式</p><ol><li>在valueOf 方法中，先判断值是否在IntegerCache 中，如果不在，就创建新的Integer(new)，否则，就直接从缓存池返回</li><li>valueOf 方法，就使用到享元模式</li></ol><h3 id="享元模式的注意事项"><a href="#享元模式的注意事项" class="headerlink" title="享元模式的注意事项"></a>享元模式的注意事项</h3><ol><li>在享元模式这样理解，“享”就表示共享，“元”表示对象</li><li>系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式</li><li>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用HashMap&#x2F;HashTable存储</li><li>享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率</li><li>享元模式提高了系统的复杂度。需要分离出内部状态和外部状态，而外部状态具有固化特性，不应该随着内部状态的改变而改变，这是我们使用享元模式需要注意的地方.</li><li>使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制。</li><li>享元模式经典的应用场景是需要缓冲池的场景，比如String常量池、数据库连接池</li></ol><h2 id="11-代理模式"><a href="#11-代理模式" class="headerlink" title="11.代理模式"></a>11.代理模式</h2><h3 id="介绍-19"><a href="#介绍-19" class="headerlink" title="介绍"></a>介绍</h3><ol><li>代理模式:为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能。</li><li>被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象</li><li>代理模式有不同的形式，主要有三种静态代理、动态代理(JDK代理、接口代理)和Cglib代理(可以在内存动态的创建对象，而不需要实现接口，他也属于动态代理的范畴)。</li></ol><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理在使用时,需要定义接口或者父类,被代理对象(即目标对象)与代理对象一起实现相同的接口或者是继承相同父类</p><p><img src="https://picture.adagio-project.icu/pic/image-20221128174348924.png" alt="image-20221128174348924"></p><p>优缺点</p><ol><li>优点:在不修改目标对象的功能前提下，能通过代理对象对目标功能扩展</li><li>缺点:因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类</li><li>一旦接口增加方法,目标对象与代理对象都要维护</li></ol><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ol><li>代理对象,不需要实现接口，但是目标对象要实现接口，否则不能用动态</li><li>代理代理对象的生成，是利用JDK的API，动态的在内存中构建代理对象</li><li>动态代理也叫做:JDK代理、接口代理</li></ol><p><img src="https://picture.adagio-project.icu/pic/image-20221128174526213.png" alt="image-20221128174526213"></p><p>核心方法是获取代理对象，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                (proxy, method, args) -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;执行代码前&quot;</span>);</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">                    System.out.println(<span class="string">&quot;执行代码后&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>ClassLoader loader :指定当前目标对象使用的类加载器，获取加载器的方法固定</p></li><li><p>Class&lt;?&gt;[] interfaces:目标对象实现的接口类型，使用泛型方法确认类型</p></li><li><p>InvocationHandler h :事件处理，执行目标对象的方法时，会触发事件处理器方法,会把当前执行的目标对象的方法作为参数传入</p></li></ol><h3 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h3><ol><li>静态代理和JDK代理模式都要求目标对象是实现一个接口,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候可使用目标对象子类来实现代理-这就是cglib代理</li></ol><ol start="2"><li>Cglib代理也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能扩展,有些书也将cglib代理归属到动态代理。</li><li>Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP，实现方法拦截</li><li>在AOP编程中如何选择代理模式:</li></ol><ol><li>目标对象需要实现接口，用JDK代理</li><li>目标对象不需要实现接口，用Cglib代理</li></ol><ol start="5"><li>Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类</li></ol><p>注意事项：</p><ol><li>在内存中动态构建子类，代理的类不能为final，否则报错</li><li>目标对象的方法如果是final&#x2F;static，那么就不会被拦截，即不会执行目标对象额外的业务方法</li></ol><p><img src="https://picture.adagio-project.icu/pic/image-20221128174737833.png" alt="image-20221128174737833"></p><p>代理工厂类代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TeacherDao target;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CGlib代理开始&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnObj</span> <span class="operator">=</span> method.invoke(target, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;CGlib代理结束&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> returnObj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个工具类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//2.设置父类</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//3.设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//4.创建子类对象，即代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(TeacherDao target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代理模式的变体"><a href="#代理模式的变体" class="headerlink" title="代理模式的变体"></a>代理模式的变体</h3><ol><li>防火墙代理<br>内网通过代理穿透防火墙，实现对公网的访间</li><li>缓存代理<br>比如:当请求图片文件等资源时，先到缓存代理取，如果取到资源则ok,如果取不到资源，再到公网或者数据库取，然后缓存。</li><li>远程代理<br>远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息。</li><li>同步代理:主要使用在多线程编程中，完成多线程间同步工作</li></ol><h2 id="12-模板方法模式"><a href="#12-模板方法模式" class="headerlink" title="12.模板方法模式"></a>12.模板方法模式</h2><h3 id="介绍-20"><a href="#介绍-20" class="headerlink" title="介绍"></a>介绍</h3><ol><li>模板方法模式(Template Method Pattern)，又叫模板模式(Template Pattern)，在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。</li><li>简单说，模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤</li><li>这种类型的设计模式属于行为型模式。</li></ol><h3 id="模拟类图"><a href="#模拟类图" class="headerlink" title="模拟类图"></a>模拟类图</h3><p><img src="https://picture.adagio-project.icu/pic/image-20221203142544123.png" alt="image-20221203142544123"></p><ol><li>AbstractClass抽象类，类中实现了模板方法(template)，定义了算法的骨架，具体子类需要去实现其它的抽象方法operation2,3,4</li><li>ConcreteClass实现抽象方法operation2,3,4，以完成算法中特定子类的步骤</li></ol><h3 id="模板方法模式的钩子方法"><a href="#模板方法模式的钩子方法" class="headerlink" title="模板方法模式的钩子方法"></a>模板方法模式的钩子方法</h3><ol><li>在模板方法模式的父类中，我们可以定义一个方法，它默认不做任何事，子类可以视情况要不要覆盖它，该方法称为“钩子”。</li></ol><h3 id="spring的IOC源码分析"><a href="#spring的IOC源码分析" class="headerlink" title="spring的IOC源码分析"></a>spring的IOC源码分析</h3><p><img src="https://picture.adagio-project.icu/pic/image-20221203151944345.png" alt="image-20221203151944345"></p><p>在ConfigurableApplicationContext中有一个refresh方法，就是模板方法，在AbstractApplicationContext中，对refresh方法进行了具体骨架搭建，其中，onRefresh和postPBeanFactory是钩子方法，可以由AbstractApplicationContext的子类进行选择性重写</p><h3 id="模板方法模式的细节"><a href="#模板方法模式的细节" class="headerlink" title="模板方法模式的细节"></a>模板方法模式的细节</h3><ol><li>基本思想是:算法只存在于一个地方，也就是在父类中，容易修改。需要修改算法时，只要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改</li><li>实现了最大化代码复用。父类的模板方法和已实现的某些步骤会被子类继承而直接使用。</li><li>既统一了算法，也提供了很大的灵活性。父类的模板方法确保了算法的结构保持不变，同时由子类提供部分步骤的实现。</li><li>该模式的不足之处:每一个不同的实现都需要一个子类实现，导致类的个数增加，使得系统更加庞大</li><li>一般模板方法都加上final关键字，防止子类重写模板方法.</li><li>模板方法模式使用场景:当要完成在某个过程，该过程要执行一系列步骤，这一系列的步骤基本相同，但其个别步骤在实现时可能不同，通常考虑用模板方法模式来处理</li></ol><h2 id="13-命令模式"><a href="#13-命令模式" class="headerlink" title="13.命令模式"></a>13.命令模式</h2><h3 id="介绍-21"><a href="#介绍-21" class="headerlink" title="介绍"></a>介绍</h3><ol><li>命令模式(Command Pattern):在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计</li><li>命名模式使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦。</li><li>在命名模式中，会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求(即命名)，同时命令模式也支持可撤销的操作。</li><li>通俗易懂的理解:将军发布命令，士兵去执行。其中有几个角色<br>将军(命令发布者)、士兵（命令的具体执行者)、命令(连接将军和士兵)。<br>Invoker是调用者（将军)，Receiver是被调用者（士兵），MyCommand是命令，实现了Command接口，持有接收对象</li></ol><h3 id="原理类图-1"><a href="#原理类图-1" class="headerlink" title="原理类图"></a>原理类图</h3><p><img src="https://picture.adagio-project.icu/pic/image-20221203160625537.png" alt="image-20221203160625537"></p><ol><li>Invoker是调用者角色</li><li>Command:是命令角色，需要执行的所有命令都在这里，可以是接口或抽象类</li><li>Receiver:接受者角色，知道如何实施和执行一个请求相关的操作</li><li>ConcreteCommand:将一个接受者对象与一个动作绑定，调用接受者相应的操作，实现execute</li></ol><h3 id="命令模式在JDBCTemplate中的使用"><a href="#命令模式在JDBCTemplate中的使用" class="headerlink" title="命令模式在JDBCTemplate中的使用"></a>命令模式在JDBCTemplate中的使用</h3><ol><li>StatementCallback接口,类似命令接口(Command)</li><li>class QueryStatementCallback implements StatementCallback<T>, SqlProvider ，实现了命令接口，同时也充当命令接收者</li><li>命令调用者是JdbcTemplate,其中execute(StatementCallback<T> action)方法中，调用action.doInStatement方法.不同的实现StatementCallback 接口的对象，对应不同的dolnStatemnt实现逻辑</li><li>另外实现 StatementCallback命令接口的子类还有QueryStatementCallback等三个类</li></ol><h3 id="命令模式的注意事项和细节"><a href="#命令模式的注意事项和细节" class="headerlink" title="命令模式的注意事项和细节"></a>命令模式的注意事项和细节</h3><ol><li>将发起请求的对象与执行请求的对象解耦。友起请灭的对家定倘用有，调用有只安调用命令对象的execute()方法就可以让接收者工作，而不必知道具体的接收者对象是谁、是如何实现的，命令对象会负责让接收者执行请求的动作，也就是说:”请求发起者”和“请求执行者”之间的解耦是通过命令对象实现的，命令对象起到了纽带桥梁的作用。</li><li>容易设计一个命令队列。只要把命令对象放到列队，就可以多线程的执行命令</li><li>容易实现对请求的撤销和重做</li><li>命令模式不足:可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这点在在使用的时候要注意</li><li>空命令也是一种设计模式，它为我们省去了判空的操作。在上面的实例中，如果没有用空命令，我们每按下一个按键都要判空，这给我们编码带来一定的麻烦。</li><li>命令模式经典的应用场景:界面的一个按钮都是一条命令、模拟CMD(DOS命令)订单的撤销&#x2F;恢复、触发-反馈机制</li></ol><h2 id="14-访问者模式"><a href="#14-访问者模式" class="headerlink" title="14.访问者模式"></a>14.访问者模式</h2><h3 id="介绍-22"><a href="#介绍-22" class="headerlink" title="介绍"></a>介绍</h3><ol><li>访问者模式(Visitor Pattern)，封装一些作用于某种数据结构的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。</li><li>主要将数据结构与数据操作分离，解决数据结构和操作耦合性问题</li><li>访问者模式的基本工作原理是:在被访问的类里面加一个对外提供接待访问者的接口</li><li>访问者模式主要应用场景是:需要对一个对象结构中的对象进行很多不同操作(这些操作彼此没有关联)，同时需要避免让这些操作”污染”这些对象的类，可以选用访问者模式解决</li></ol><h3 id="原理类图-2"><a href="#原理类图-2" class="headerlink" title="原理类图"></a>原理类图</h3><p><img src="https://picture.adagio-project.icu/pic/image-20221204145507320.png" alt="image-20221204145507320"></p><ol><li>Visitor是抽象访问者，为该对象结构中的Concret eElenent的每一个类声明一个visit操作</li><li>ConcreteVisitor:是一个具体的访问值实现每个有Visitor声明的操作，是每个操作实现的部分.</li><li>0bjectStructure能枚举它的元素，可以提供一个高层的接口，用来允许访问者访问元素</li><li>Element定义一个accept方法，接收一个访问者对象</li><li>ConcreteElenent为具体元素,实现了accept方法</li></ol><h3 id="访问者模式的注意事项"><a href="#访问者模式的注意事项" class="headerlink" title="访问者模式的注意事项"></a>访问者模式的注意事项</h3><p>优点</p><ol><li>访问者模式符合单一职责原则、让程序具有优秀的扩展性、灵活性非常高</li><li>访问者模式可以对功能进行统一，可以做报表、UI、拦截器与过滤器，适用于数据结构相对稳定的系统</li></ol><p>缺点</p><ol><li>具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的，这样造成了具体元素变更比较困难</li><li>违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素</li><li>因此，如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问者模式就是比较合适的.</li></ol><h2 id="15-迭代器模式"><a href="#15-迭代器模式" class="headerlink" title="15.迭代器模式"></a>15.迭代器模式</h2><h3 id="介绍-23"><a href="#介绍-23" class="headerlink" title="介绍"></a>介绍</h3><ol><li>迭代器模式( lterator Pattern）是常用的设计模式，属于行为型模式</li><li>如果我们的集合元素是用不同的方式实现的，有数组，还有java集合类或者还有其他方式，当客户端需要遍历这些元素的时候就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。</li><li>迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示，即:不暴露其内部的结构。</li></ol><h3 id="原理类图-3"><a href="#原理类图-3" class="headerlink" title="原理类图"></a>原理类图</h3><p><img src="https://picture.adagio-project.icu/pic/image-20221204164422036.png" alt="image-20221204164422036"></p><ol><li>Iterator:迭代器接口·是系统程供，含义 hasNext, next, removeConcreteIterator:具体的迭代器类,管理迭代</li><li>Aggregate :一个统一的聚合聚合接口,将客户端和具体聚合解耦</li><li>ConcreteAggregate :具体的聚合持有对象集合并提供一个方法，返回一个达代器，该迭代器可以正确遍历集合</li><li>Client:客户端,通过iterator和Aggregate依赖子类</li></ol><h3 id="jdk中的迭代器模式"><a href="#jdk中的迭代器模式" class="headerlink" title="jdk中的迭代器模式"></a>jdk中的迭代器模式</h3><p><img src="https://picture.adagio-project.icu/pic/image-20221204192609909.png" alt="image-20221204192609909"></p><ol><li>内部类ltr充当具体实现迭代器lterator的类，作为ArrayList内部类</li><li>List就是充当了聚合接口，含有一个iterator()方法，返回一个</li><li>ArrayList是实现聚合接口List的子类，实现了iterator()</li><li>lterator接口系统提供</li><li>迭代器模式解决了不同集合(ArrayList ,LinkedList)统一遍历问题</li></ol><h3 id="迭代器模式的注意细节"><a href="#迭代器模式的注意细节" class="headerlink" title="迭代器模式的注意细节"></a>迭代器模式的注意细节</h3><p>优点</p><ol><li>提供一个统一的方法遍历对象，客户不用再考虑聚合的类型，使用一种方法就可以遍历对象了。</li><li>隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不会知道聚合的具体组成。</li><li>提供了一种设计思想，就是一个类应该只有一个引起变化的原因（叫做单一责任原则)。在聚合类中，我们把迭代器分开，就是要把管理对象集合和遍历对象集合的责任分开，这样一来集合改变的话，只影响到聚合对象。而如果遍历方式改变的话,只影响到了迭代器。</li><li>当要展示一组相似对象，或者遍历一组相同对象时使用，适合使用迭代器模式</li></ol><p>缺点</p><ol><li>每个聚合对象都要一个迭代器，会生成多个迭代器不好管理类</li></ol><h2 id="16-观察者模式"><a href="#16-观察者模式" class="headerlink" title="16.观察者模式"></a>16.观察者模式</h2><h3 id="介绍-24"><a href="#介绍-24" class="headerlink" title="介绍"></a>介绍</h3><p>观察者模式:对象之间多对一依赖的一种设计方案，被依赖的对象为Subject，依赖的对象为Observer，Subject通知Observer变化,</p><h3 id="原理类图-4"><a href="#原理类图-4" class="headerlink" title="原理类图"></a>原理类图</h3><p><img src="https://picture.adagio-project.icu/pic/image-20221205141900260.png" alt="image-20221205141900260"></p><p>优点</p><ol><li>观察者模式设计后，会以集合的方式来管理用户(Observer)，包括注册，移除和通知。</li><li>这样，我们增加观察者(这里可以理解成一个新的公告板)，就不需要去修改核心类WeatherData不会修改代码，遵守了ocp原则。</li></ol><h3 id="观察者模式在JDK源码的分析"><a href="#观察者模式在JDK源码的分析" class="headerlink" title="观察者模式在JDK源码的分析"></a>观察者模式在JDK源码的分析</h3><ol><li>Observable的作用和地位等价于我们前面讲过Subject</li><li>Observable是类，不是接口，类中已经实现了核心的方法,即管理Observer的方法add.. delete .. notify…</li><li>Observer的作用和地位等价于我们前面讲过的Observer,有update</li><li>Observable和 Observer的使用方法和前面讲过的一样，只是Observable是类，通过继承来说实现观察者模式</li></ol><h2 id="17-中介者模式"><a href="#17-中介者模式" class="headerlink" title="17.中介者模式"></a>17.中介者模式</h2><h3 id="介绍-25"><a href="#介绍-25" class="headerlink" title="介绍"></a>介绍</h3><ol><li>中介者模式(Mediator Pattern)，用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互</li><li>中介者模式属于行为型模式，使代码易于维护</li><li>比如MVC模式，c (Controller控制器）是M(Model模型）和v (View视图）的中介者，在前后端交互时起到了中间人的作用</li></ol><h3 id="原理类图-5"><a href="#原理类图-5" class="headerlink" title="原理类图"></a>原理类图</h3><p><img src="https://picture.adagio-project.icu/pic/image-20221205161544777.png" alt="image-20221205161544777"></p><ol><li>Mediator就是抽象中介者,定义了同事对象到中介者对象的接口</li><li>Colleague是抽象同事类</li><li>ConcreteMediator具体的中介者对象，实现抽象方法，他需要知道所有的具体的同事类,即以一个集合来管理HashMap,并接受某个同事对象消息,完成相应的任务</li><li>ConcreteColleague具体的同事类，会有很多，每个同事只知道自己的行为，而不了解其他同事类的行为(方法)，但是他们都依赖中介者对象</li></ol><h3 id="案例模拟类图"><a href="#案例模拟类图" class="headerlink" title="案例模拟类图"></a>案例模拟类图</h3><p><img src="https://picture.adagio-project.icu/pic/image-20221205171339989.png" alt="image-20221205171339989"></p><p>目的是不让Colleague子类对象相互之间产生各种关联，把相互调用的工作交给中介者来做，达到解耦目的</p><h3 id="中介者模式的注意事项"><a href="#中介者模式的注意事项" class="headerlink" title="中介者模式的注意事项"></a>中介者模式的注意事项</h3><ol><li>多个类相互耦合，会形成网状结构，使用中介者模式将网状结构分离为星型结构，进行解耦</li><li>减少类间依赖，降低了耦合，符合迪米特原则</li><li>中介者承担了较多的责任，一旦中介者出现了问题，整个系统就会受到影响</li><li>如果设计不当，中介者对象本身变得过于复杂，这点在实际使用时，要特别注意</li></ol><h2 id="18-备忘录模式"><a href="#18-备忘录模式" class="headerlink" title="18.备忘录模式"></a>18.备忘录模式</h2><h3 id="介绍-26"><a href="#介绍-26" class="headerlink" title="介绍"></a>介绍</h3><ol><li>备忘录模式(Memento Pattern）在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态</li><li>可以这里理解备忘录模式:现实生活中的备忘录是用来记录某些要去做的事情，或者是记录已经达成的共同意见的事情，以防忘记了。而在软件层面，备忘录模式有着相同的含义，备忘录对象主要用来记录一个对象的某种状态，或者某些数据，当要做回退时，可以从备忘录对象里获取原来的数据进行恢复操作</li><li>备忘录模式属于行为型模式</li></ol><h3 id="原理类图-6"><a href="#原理类图-6" class="headerlink" title="原理类图"></a>原理类图</h3><p><img src="https://picture.adagio-project.icu/pic/image-20221206140652873.png" alt="image-20221206140652873"></p><ol><li>originator :对象(需要保存状态的对象)</li><li>Memento :备忘录对象,负责保存好记录，即Originator内部状态</li><li>Caretaker:守护者对象,负责保存多个备忘录对象，使用集合管理，提高效率</li><li>说明:如果希望保存多个originator对象的不同时间的状态，也可以，只需要要HashMap&lt;String，集合&gt;</li></ol><h3 id="备忘录模式的注意事项"><a href="#备忘录模式的注意事项" class="headerlink" title="备忘录模式的注意事项"></a>备忘录模式的注意事项</h3><ol><li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态</li><li>实现了信息的封装，使得用户不需要关心状态的保存细节</li><li>如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存,这个需要注意</li><li>适用的应用场景:1、后悔药。2、打游戏时的存档。3.Windows里的ctrl+ Z。4、IE中的后退。4、数据库的事务管理</li><li>为了节约内存，备忘录模式可以和原型模式配合使用</li></ol><h2 id="19-解释器模式"><a href="#19-解释器模式" class="headerlink" title="19.解释器模式"></a>19.解释器模式</h2><h3 id="介绍-27"><a href="#介绍-27" class="headerlink" title="介绍"></a>介绍</h3><ol><li>在编译原理中，一个算术表达式通过词法分析器形成词法单元，而后这些词法单元再通过语法分析器构建语法分析树，最终形成一颗抽象的语法分析树。这里的词法分析器和语法分析器都可以看做是解释器</li><li>解释器模式( Interpreter Pattern):是指给定一个语言(表达式)，定义它的文法的一种表示，并定义一个解释器，使用该解释器来解释语言中的句子(表达式)</li><li>应用场景<ol><li>应用可以将一个需要解释执行的语言中的句子表示为一个抽象语法树</li><li>一些重复出现的问题可以用一种简单的语言来表达</li><li>一个简单语法需要解释的场景</li></ol></li><li>这样的例子还有，比如编译器、运算表达式计算、正则表达式、机器人等</li></ol><h3 id="原理类图-7"><a href="#原理类图-7" class="headerlink" title="原理类图"></a>原理类图</h3><p><img src="https://picture.adagio-project.icu/pic/image-20221206192340254.png" alt="image-20221206192340254"></p><ol><li>Context:是环境角色,含有解释器之外的全局信息.</li><li>AbstractExpression:抽象表达式，声明一个抽象的解释操作,这个方法为抽象语法树中所有的节点所共享</li><li>TerminalExpression:为终结符表达式，实现与文法中的终结符相关的解释操作</li><li>NonTermialExpression:为非终结符表达式，为文法中的非终结符实现解释操作.</li><li>说明:输入Context 和 TerminalExpression信息通过client输入即可</li></ol><h3 id="解释器模式在Spring里的运用"><a href="#解释器模式在Spring里的运用" class="headerlink" title="解释器模式在Spring里的运用"></a>解释器模式在Spring里的运用</h3><ol><li>Expression接口表达式接口</li><li>下面有不同的实现类，比如SpelExpression，或者CompositeStringExpression。</li><li>使用时候，根据你创建的不同的Parser对象，返回不同的 Expression对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Expression <span class="title function_">parseExpression</span><span class="params">(String expressionString, ParserContext context)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">null</span>) &#123;</span><br><span class="line">        context = NON_TEMPLATE_PARSER_CONTEXT;</span><br><span class="line">        <span class="keyword">if</span> (context.isTemplate(<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> parseTemplate(expressionString, context);</span><br><span class="line">            <span class="comment">//返回的就是CompositeStringExpression</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> doParseExpression(expressionString, context);</span><br><span class="line">            <span class="comment">//返回的就是SpelExpression</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>使用得当Expression对象，调用getValue解释执行表达式，最后得到结果</li></ol><p><img src="https://picture.adagio-project.icu/pic/image-20221206204339551.png" alt="image-20221206204339551"></p><h3 id="解释器模式的注意事项"><a href="#解释器模式的注意事项" class="headerlink" title="解释器模式的注意事项"></a>解释器模式的注意事项</h3><ol><li>当有一个语言需要解释执行，可将该语言中的句子表示为一个抽象语法树，就可以考虑使用解释器模式,让程序具有良好的扩展性</li><li>应用场景:编译器、运算表达式计算、正则表达式、机器人等</li><li>使用解释器可能带来的问题:解释器模式会引起类膨胀、解释器模式采用递归调用方法，将会导致调试非常复杂、效率可能降低.</li></ol><h2 id="20-状态模式"><a href="#20-状态模式" class="headerlink" title="20.状态模式"></a>20.状态模式</h2><h3 id="介绍-28"><a href="#介绍-28" class="headerlink" title="介绍"></a>介绍</h3><ol><li>状态模式(State Pattern):它主要用来解决对象在多种状态转换时，需要对外输出不同的行为的问题。状态和行为是一一对应的，状态之间可以相互转换</li><li>当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了其类</li></ol><h3 id="原理类图-8"><a href="#原理类图-8" class="headerlink" title="原理类图"></a>原理类图</h3><p><img src="https://picture.adagio-project.icu/pic/image-20221207151129964.png" alt="image-20221207151129964"></p><ol><li>Context类为环境角色，用于维护State实例,这个实例定义当前状态</li><li>State是抽象状态角色,定义一个接口封装与Context的个特点接口相关行为</li><li>ConcreteState具体的状态角色，每个子类实现一个与Context的一个状态相关行为</li></ol><h3 id="状态模式的注意事项"><a href="#状态模式的注意事项" class="headerlink" title="状态模式的注意事项"></a>状态模式的注意事项</h3><ol><li>代码有很强的可读性。状态模式将每个状态的行为封装到对应的一个类中</li><li>方便维护。将容易产生问题的if-else语句删除了，如果把每个状态的行为都放到一个类中，每次调用方法时都要判断当前是什么状态，不但会产出很多if-else语句，而且容易出错</li><li>符合“开闭原则”。容易增删状态</li><li>会产生很多类。每个状态都要一个对应的类，当状态过多时会产生很多类，加大维护难度</li><li>当一个事件或者对象有很多种状态，状态之间会相互转换，对不同的状态要求有不同的行为的时候，可以考虑使用状态模式</li></ol><h2 id="21-策略模式"><a href="#21-策略模式" class="headerlink" title="21.策略模式"></a>21.策略模式</h2><h3 id="介绍-29"><a href="#介绍-29" class="headerlink" title="介绍"></a>介绍</h3><ol><li>策略模式(Strategy Pattern）中，定义算法族，分别封装起来，让他们之间可以互相替换,此模式让算法的变化独立于使用算法的客户</li><li>这算法体现了几个设计原则，第一、把变化的代码从不变的代码中分离出来;第二、针对接口编程而不是具体类（定义了策略接口)﹔第三、多用组合&#x2F;聚合，少用继承(客户通过组合方式使用策略）。</li></ol><h3 id="原理类图-9"><a href="#原理类图-9" class="headerlink" title="原理类图"></a>原理类图</h3><p><img src="https://picture.adagio-project.icu/pic/image-20221207205308482.png" alt="image-20221207205308482"></p><p>说明: 从上图可以看到，客户context有成员变量strategy或者其他的策略接口，至于需要使用到哪个策略，我们可以在构造器中指定.</p><h3 id="策略模式在JDK源码中的使用"><a href="#策略模式在JDK源码中的使用" class="headerlink" title="策略模式在JDK源码中的使用"></a>策略模式在JDK源码中的使用</h3><p>在JDK中有一个Comparator接口，在调用Arrays.sort方法时我们可以传入一个Comparator对象，这个对象可以由我们自定义比较规则，所以在这里，Comparator就是策略接口，我们创建的Comparator对象就是具体策略，而Arrays.sort这个方法就是接受策略的对象</p><h3 id="策略模式的注意事项"><a href="#策略模式的注意事项" class="headerlink" title="策略模式的注意事项"></a>策略模式的注意事项</h3><ol><li>策略模式的关键是:分析项目中变化部分与不变部分</li><li>策略模式的核心思想是:多用组合&#x2F;聚合少用继承;用行为类组合，而不是行为的继承。更有弹性</li><li>体现了“对修改关闭，对扩展开放”原则，客户端增加行为不用修改原有代码，只要添加一种策略（或者行为）即可，避免了使用多重转移语句(if..else if..else)</li><li>提供了可以替换继承关系的办法:策略模式将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展</li><li>需要注意的是:每添加一个策略就要增加一个类，当策略过多是会导致类数目庞大</li></ol><h2 id="22-职责链模式"><a href="#22-职责链模式" class="headerlink" title="22.职责链模式"></a>22.职责链模式</h2><h3 id="介绍-30"><a href="#介绍-30" class="headerlink" title="介绍"></a>介绍</h3><ol><li>职责链模式(Chain of Responsibility Pattern) ,又叫责任链模式，为请求创建了一个接收者对象的链。这种模式对请求的发送者和接收者进行解耦。</li><li>职责链模式通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</li><li>这种类型的设计模式属于行为型模式</li></ol><h3 id="原理类图-10"><a href="#原理类图-10" class="headerlink" title="原理类图"></a>原理类图</h3><p><img src="https://picture.adagio-project.icu/pic/image-20221207215729601.png" alt="image-20221207215729601"></p><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链,并沿着这条链传递该请求，直到有一个对象处理它为止.</p><ol><li>Handler:抽象的处理者，定义了一个处理请求的接口，同时含义另外Handler</li><li>ConcreteHandlerA , B是具体的处理者，处理它自己负责的请求，可以访问它的后继者(即下一个处理者)，如果可以处理当前请求，则处理，否则就将该请求交给后继者去处理，从而形成一个职责链</li><li>Request ,含义很多属性，表示一个请求</li></ol><h3 id="职责链模式在SpringMVC中的运用"><a href="#职责链模式在SpringMVC中的运用" class="headerlink" title="职责链模式在SpringMVC中的运用"></a>职责链模式在SpringMVC中的运用</h3><ol><li>springmvc 请求的流程图中，执行了拦截器相关方法interceptor.preHandler等等</li><li>在处理SpringMvc请求时，使用到职责链模式还使用到适配器模式</li><li>HandlerExecutionChain主要负责的是请求拦截器的执行和请求处理,但是他本身不处理请求，只是将请求分配给链上注册处理器执行，这是职责链实现方式,减少职责链本身与处理逻辑之间的耦合,规范了处理流程</li><li>HandlerExecutionChain维护了HandlerInterceptor的集合，可以向其中注册相应的拦截器.</li></ol><h3 id="职责链模式的注意事项"><a href="#职责链模式的注意事项" class="headerlink" title="职责链模式的注意事项"></a>职责链模式的注意事项</h3><ol><li>将请求和处理分开，实现解耦，提高系统的灵活性</li><li>简化了对象，使对象不需要知道链的结构</li><li>性能会受到影响，特别是在链比较长的时候，因此需控制链中最大节点数量，一般通过在Handler中设置一个最大节点数量，在setNext()方法中判断是否已经超过阀值，超过则不允许该链建立，避免出现超长链无意识地破坏系统性能</li><li>调试不方便。采用了类似递归的方式，调试时逻辑可能比较复杂</li><li>最佳应用场景:有多个对象可以处理同一个请求时，比如:多级请求、请假&#x2F;加薪等审批流程、Java Web中Tomcat对Encoding的处理、拦截器</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
